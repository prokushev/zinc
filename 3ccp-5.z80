;
;**** Section 5 ****
; CPR-Resident Commands
;
;
;Section 5A
;Command: DIR
;Function:  To display a directory of the files on disk
;Forms:
;	DIR <afn>	Displays the DIR files
;	DIR <afn> S	Displays the SYS files
;	DIR <afn> A	Display both DIR and SYS files
;
DIR:	
	LD	A,80H		;SET SYSTEM BIT EXAMINATION
	PUSH	AF
	CALL	SCANER		;EXTRACT POSSIBLE D:FILENAME.TYP TOKEN
	CALL	SLOGIN		;LOG IN DRIVE IF NECESSARY
	LD	HL,FCBFN	;MAKE FCB WILD (ALL '?') IF NO FILENAME.TYP
	LD	A,(HL)		;GET FIRST CHAR OF FILENAME.TYP
	CP	' '		;IF <SP>, ALL WILD
	CALL	Z,FILLQ
	CALL	ADVAN		;LOOK AT NEXT INPUT CHAR
	LD	B,0		;SYS TOKEN DEFAULT
	JR      Z,DIR2		;JUMP; THERE ISN'T ONE
	CP	SYSFLG		;SYSTEM FLAG SPECIFIER?
	JR      Z,GOTSYS		;GOT SYSTEM SPECIFIER
	CP	SOFLG		;SYS ONLY?
	JR      NZ,DIR2
	LD	B,80H		;FLAG SYS ONLY
GOTSYS:	
	INC	DE
	LD	(CIBPTR),DE
	CP	SOFLG		;SYS ONLY SPEC?
	JR      Z,DIR2		;THEN LEAVE BIT SPEC UNCHAGNED
	POP	AF		;GET FLAG
	XOR	A		;SET NO SYSTEM BIT EXAMINATION
	PUSH	AF 
DIR2:	
	POP	AF		;GET FLAG
DIR2A:	
	;DROP INTO DIRPR TO PRINT DIRECTORY
	; THEN RESTART CPR
;
; DIRECTORY PRINT ROUTINE; ON ENTRY, MSB OF A IS 1 (80H) IF SYSTEM FILES EXCL
;
DIRPR:	
	LD	D,A		;STORE SYSTEM FLAG IN D
	LD	E,0		;SET COLUMN COUNTER TO ZERO
	PUSH	DE		;SAVE COLUMN COUNTER (E) AND SYSTEM FLAG (D)
	LD	A,B		;SYS ONLY SPECIFIER
	LD	(SYSTST),A
	CALL	SEARF		;SEARCH FOR SPECIFIED FILE (FIRST OCCURRANCE)
	CALL	Z,PRNNF	;PRINT NO FILE MSG;REG A NOT CHANGED
;
; ENTRY SELECTION LOOP; ON ENTRY, A=OFFSET FROM SEARF OR SEARN
;
DIR3:	
	JR      Z,DIR11		;DONE IF ZERO FLAG SET
	DEC	A		;ADJUST TO RETURNED VALUE
	RRCA			;CONVERT NUMBER TO OFFSET INTO TBUFF
	RRCA	
	RRCA	
	AND	60H
	LD	C,A		;OFFSET INTO TBUFF IN C (C=OFFSET TO ENTRY)
	LD	A,10		;ADD 10 TO PT TO SYSTEM FILE ATTRIBUTE BIT
	CALL	DIRPTR
	POP	DE		;GET SYSTEM BIT MASK FROM D
	PUSH	DE
	AND	D		;MASK FOR SYSTEM BIT
SYSTST:	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER SYSTST
	CP	0
	JR      NZ,DIR10
	POP	DE		;GET ENTRY COUNT (=<CR> COUNTER)
	LD	A,E		;ADD 1 TO IT
	INC	E
	PUSH	DE		;SAVE IT
	AND	03H		;OUTPUT <CRLF> IF 4 ENTRIES PRINTED IN LINE
	PUSH	AF
	JR      NZ,DIR4
	CALL	CRLF		;NEW LINE
	JR	DIR5
DIR4:	
	CALL	PRINT
;
	IF	WIDE
	DEFB	'  '		;2 SPACES
	DEFB	FENCE		;THEN FENCE CHAR
	DEFB	' ',' '+80H	;THEN 2 MORE SPACES
	ENDIF	
;
	IF	NOT WIDE
	DEFB	' '		;SPACE
	DEFB	FENCE		;THEN FENCE CHAR
	DEFB	' '+80H		;THEN SPACE
	ENDIF	
;
DIR5:	
	LD	B,01H		;PT TO 1ST BYTE OF FILE NAME
DIR6:	
	LD	A,B		;A=OFFSET
	CALL	DIRPTR		;HL NOW PTS TO 1ST BYTE OF FILE NAME
	AND	7FH		;MASK OUT MSB
	CP	' '		;NO FILE NAME?
	JR      NZ,DIR8		;PRINT FILE NAME IF PRESENT
	POP	AF
	PUSH	AF
	CP	03H
	JR      NZ,DIR7
	LD	A,09H		;PT TO 1ST BYTE OF FILE TYPE
	CALL	DIRPTR		;HL NOW PTS TO 1ST BYTE OF FILE TYPE
	AND	7FH		;MASK OUT MSB
	CP	' '		;NO FILE TYPE?
	JR      Z,DIR9		;CONTINUE IF SO
DIR7:	
	LD	A,' '		;OUTPUT <SP>
DIR8:	
	CALL	CONOUT		;PRINT CHAR
	INC	B		;INCR CHAR COUNT
	LD	A,B
	CP	12		;END OF FILENAME.TYP?
	JR      NC,DIR9		;CONTINUE IF SO
	CP	09H		;END IF FILENAME ONLY?
	JR      NZ,DIR6		;PRINT TYP IF SO
	LD	A,'.'		;PRINT DOT BETWEEN FILE NAME AND TYPE
	CALL	CONOUT
	JR	DIR6
DIR9:	
	POP	AF
DIR10:	
	CALL	BREAK		;CHECK FOR ABORT
	JR      NZ,DIR11
	CALL	SEARN		;SEARCH FOR NEXT FILE
	JR	DIR3		;CONTINUE
DIR11:	
	POP	DE		;RESTORE STACK
	RET	
;
; FILL FCB @HL WITH '?'
;
FILLQ:	
	LD	B,11		;NUMBER OF CHARS IN FN & FT
FQLP:	
	LD	(HL),'?'	;STORE '?'
	INC	HL
	DJNZ	FQLP
	RET	
;
;Section 5B
;Command: ERA
;Function:  Erase files
;Forms:
;	ERA <afn>	Erase Specified files and print their names
;
	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
;
ERA:	
	CALL	SCANER		;PARSE FILE SPECIFICATION
	CP	11		;ALL WILD (ALL FILES = 11 '?')?
	JR      NZ,ERA1		;IF NOT, THEN DO ERASES
	CALL	PRINTC
	DEFB	'All','?'+80H
	CALL	CONIN		;GET REPLY
	CP	'Y'		;YES?
	JP	NZ,RESTRT	;RESTART CPR IF NOT
	CALL	CRLF		;NEW LINE
ERA1:	
	CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
	XOR	A		;PRINT ALL FILES (EXAMINE SYSTEM BIT)
	LD	B,A		;NO SYS-ONLY OPT TO DIRPR
	CALL	DIRPR		;PRINT DIRECTORY OF ERASED FILES
	LD	DE,FCBDN	;DELETE FILE SPECIFIED
	CALL	DELETE
	RET			;REENTER CPR
;
	ENDIF			;RAS
;
;Section 5C
;Command: LIST
;Function:  Print out specified file on the LST: Device
;Forms:
;	LIST <ufn>	Print file (NO Paging)
;
	IF	Z_LIST
LISTC:	
	LD	A,0FFH		;TURN ON PRINTER FLAG
	JR	TYPE0
	ENDIF
;
;Section 5D
;Command: TYPE
;Function:  Print out specified file on the CON: Device
;Forms:
;	TYPE <ufn>	Print file
;	TYPE <ufn> P	Print file with paging flag	
;
TYPE:	
	XOR	A		;TURN OFF PRINTER FLAG
;
; ENTRY POINT FOR CPR LIST FUNCTION (LIST)
;
TYPE0:	
	LD	(PRFLG),A	;SET FLAG
	CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
	JP	NZ,ERROR	;ERROR IF ANY QUESTION MARKS
	CALL	ADVAN		;GET PGDFLG IF IT'S THERE
	LD	(PGFLG),A	;SAVE IT AS A FLAG
	JR      Z,NOSLAS		;JUMP IF INPUT ENDED
	INC	DE		;PUT NEW BUF POINTER
	EX	DE,HL
	LD	(CIBPTR),HL
NOSLAS:	
	CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
	CALL	OPENF		;OPEN SELECTED FILE
	JP	Z,TYPE4	;ABORT IF ERROR
	CALL	CRLF		;NEW LINE
	LD	A,NLINES-1	;SET LINE COUNT
	LD	(PAGCNT),A
	LD	HL,CHRCNT	;SET CHAR POSITION/COUNT
	LD	(HL),0FFH	;EMPTY LINE
	LD	B,0		;SET TAB CHAR COUNTER
TYPE1:	
	LD	HL,CHRCNT	;PT TO CHAR POSITION/COUNT
	LD	A,(HL)		;END OF BUFFER?
	CP	80H
	JR      C,TYPE2
	PUSH	HL		;READ NEXT BLOCK
	CALL	READF
	POP	HL
	JR      NZ,TYPE3		;ERROR?
	XOR	A		;RESET COUNT
	LD	(HL),A
TYPE2:	
	INC	(HL)		;INCREMENT CHAR COUNT
	LD	HL,TBUFF	;PT TO BUFFER
	CALL	ADDAH		;COMPUTE ADDRESS OF NEXT CHAR FROM OFFSET
	LD	A,(HL)		;GET NEXT CHAR
	AND	7FH		;MASK OUT MSB
	CP	1AH		;END OF FILE (^Z)?
	RET	Z		;RESTART CPR IF SO
;
; OUTPUT CHAR TO CON: OR LST: DEVICE WITH TABULATION
;
	CP	CR		;RESET TAB COUNT?
	JR      Z,TABRST
	CP	LF		;RESET TAB COUNT?
	JR      Z,TABRST
	CP	TAB		;TAB?
	JR      Z,LTAB
	CALL	LCOUT		;OUTPUT CHAR
	INC	B		;INCREMENT CHAR COUNT
	JR	TYPE2L
TABRST:	
	CALL	LCOUT		;OUTPUT <CR> OR <LF>
	LD	B,0		;RESET TAB COUNTER
	JR	TYPE2L
LTAB:	
	LD	A,' '		;<SP>
	CALL	LCOUT
	INC	B		;INCR POS COUNT
	LD	A,B
	AND	7
	JR      NZ,LTAB
;
; CONTINUE PROCESSING
;
TYPE2L:	
	CALL	BREAK		;CHECK FOR ABORT
	JR      Z,TYPE1		;CONTINUE IF NO CHAR
	CP	'C'-'@'		;^C?
	RET	Z		;RESTART IF SO
	JR	TYPE1
TYPE3:	
	DEC	A		;NO ERROR?
	RET	Z		;RESTART CPR
TYPE4:	
	JP	ERRLOG
;
; PAGING ROUTINES
;   PAGER COUNTS DOWN LINES AND PAUSES FOR INPUT (DIRECT) IF COUNT EXPIRES
;   PAGSET SETS LINES/PAGE COUNT
;
PAGER:	
	PUSH	HL
	LD	HL,PAGCNT	;COUNT DOWN
	DEC	(HL)
	JR      NZ,PGBAK		;JUMP IF NOT END OF PAGE
	LD	(HL),NLINES-2	;REFILL COUNTER
;
PGFLG:	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER PGFLG
	LD	A,0		;0 MAY BE CHANGED BY PGFLG EQUATE
	CP	PGDFLG		;PAGE DEFAULT OVERRIDE OPTION WANTED?
;
	IF	PGDFLT		;IF PAGING IS DEFAULT
	JR      Z,PGBAK		;  PGDFLG MEANS NO PAGING, PLEASE
	ELSE			;IF PAGING NOT DEFAULT
	JR      NZ,PGBAK		;  PGDFLG MEANS PLEASE PAGINATE
	ENDIF	
;
	CALL	CONIN		;GET CHAR TO CONTINUE
	CP	'C'-'@'		;^C
	JP	Z,RSTCPR	;RESTART CPR
PGBAK:	
	POP	HL		;RESTORE HL
	RET	
;
;Section 5E
;Command: SAVE
;Function:  To save the contents of the TPA onto disk as a file
;Forms:
;	SAVE <Number of Pages> <ufn>
;				Save specified number of pages (start at 100H)
;				from TPA into specified file; <Number of
;				Pages> is in DEC
;	SAVE <Number of Sectors> <ufn> S
;				Like SAVE above, but numeric argument specifies
;				number of sectors rather than pages
;
	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
	IF	Z_SAVE
;
SAVE:	
	CALL	NUMBER		;EXTRACT NUMBER FROM COMMAND LINE
	LD	L,A		;HL=PAGE COUNT
	LD	H,0
	PUSH	HL		;SAVE PAGE COUNT
	CALL	EXTEST		;TEST FOR EXISTENCE OF FILE AND ABORT IF SO
	LD	C,16H		;BDOS MAKE FILE
	CALL	GRBDOS
	POP	HL		;GET PAGE COUNT
	JR      Z,SAVE3		;ERROR?
	XOR	A		;SET RECORD COUNT FIELD OF NEW FILE'S FCB
	LD	(FCBCR),A
	CALL	ADVAN		;LOOK FOR 'S' FOR SECTOR OPTION
	INC	DE		;PT TO AFTER 'S' TOKEN
	CP	SECTFLG
	JR      Z,SAVE0
	DEC	DE		;NO 'S' TOKEN, SO BACK UP
	ADD	HL,HL		;DOUBLE IT FOR HL=SECTOR (128 BYTES) COUNT
SAVE0:	
	LD	(CIBPTR),DE		;SET PTR TO BAD TOKEN OR AFTER GOOD TOKEN
	LD	DE,TPA		;PT TO START OF SAVE AREA (TPA)
SAVE1:	
	LD	A,H		;DONE WITH SAVE?
	OR	L		;HL=0 IF SO
	JR      Z,SAVE2
	DEC	HL		;COUNT DOWN ON SECTORS
	PUSH	HL		;SAVE PTR TO BLOCK TO SAVE
	LD	HL,128		;128 BYTES PER SECTOR
	ADD	HL,DE		;PT TO NEXT SECTOR
	PUSH	HL		;SAVE ON STACK
	CALL	DMASET		;SET DMA ADDRESS FOR WRITE (ADDRESS IN DE)
	LD	DE,FCBDN	;WRITE SECTOR
	LD	C,15H		;BDOS WRITE SECTOR
	CALL	BDOSB		;SAVE BC
	POP	DE		;GET PTR TO NEXT SECTOR IN DE
	POP	HL		;GET SECTOR COUNT
	JR      NZ,SAVE3		;WRITE ERROR?
	JR	SAVE1		;CONTINUE
SAVE2:	
	LD	DE,FCBDN	;CLOSE SAVED FILE
	CALL	CLOSE
	INC	A		;ERROR?
	JR      NZ,SAVE4
SAVE3:	
	CALL	PRNLE		;PRINT 'NO SPACE' ERROR
SAVE4:	
	CALL	DEFDMA		;SET DMA TO 0080
	RET			;RESTART CPR
	ENDIF
;
; Test File in FCB for existence, ask user to delete if so, and abort if he
;  choses not to
;
EXTEST:	
	CALL	SCANER		;EXTRACT FILE NAME
	JP	NZ,ERROR	;'?' IS NOT PERMITTED
	CALL	SLOGIN		;LOG IN SELECTED DISK
	CALL	SEARF		;LOOK FOR SPECIFIED FILE
	LD	DE,FCBDN	;PT TO FILE FCB
	RET	Z		;OK IF NOT FOUND
	PUSH	DE		;SAVE PTR TO FCB
	CALL	PRINTC
	DEFB	'Delete File','?'+80H
	CALL	CONIN		;GET RESPONSE
	POP	DE		;GET PTR TO FCB
	CP	'Y'		;KEY ON YES
	JP	NZ,RSTCPR	;RESTART IF NO
	PUSH	DE		;SAVE PTR TO FCB
	CALL	DELETE		;DELETE FILE
	POP	DE		;GET PTR TO FCB
	RET	
;
	ENDIF			;RAS
;
;Section 5F
;Command: REN
;Function:  To change the name of an existing file
;Forms:
;	REN <New ufn>=<Old ufn>	Perform function
;
	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
;
REN:	
	CALL	EXTEST		;TEST FOR FILE EXISTENCE AND RETURN
	; IF FILE DOESN'T EXIST; ABORT IF IT DOES
	LD	A,(TEMPDR)	;SAVE CURRENT DEFAULT DISK
	PUSH	AF		;SAVE ON STACK
REN0:	
	LD	HL,FCBDN	;SAVE NEW FILE NAME
	LD	DE,FCBDM
	LD	BC,16		;16 BYTES
	LDIR	
	CALL	ADVAN		;ADVANCE CIBPTR
	CP	'='		;'=' OK
	JR      NZ,REN4
REN1:	
	EX	DE,HL		;PT TO CHAR AFTER '=' IN HL
	INC	HL
	LD	(CIBPTR),HL	;SAVE PTR TO OLD FILE NAME
	CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
	JR      NZ,REN4		;ERROR IF ANY '?'
	POP	AF		;GET OLD DEFAULT DRIVE
	LD	B,A		;SAVE IT
	LD	HL,TEMPDR	;COMPARE IT AGAINST CURRENT DEFAULT DRIVE
	LD	A,(HL)		;MATCH?
	OR	A
	JR      Z,REN2
	CP	B		;CHECK FOR DRIVE ERROR
	LD	(HL),B
	JR      NZ,REN4
REN2:	
	LD	(HL),B
	XOR	A
	LD	(FCBDN),A	;SET DEFAULT DRIVE
	LD	DE,FCBDN	;RENAME FILE
	LD	C,17H		;BDOS RENAME FCT
	CALL	GRBDOS
	RET	NZ
REN3:	
	CALL	PRNNF		;PRINT NO FILE MSG
REN4:	
	JP	ERRLOG
;
	ENDIF			;RAS
;
;Section 5G
;Command: USER
;Function:  Change current USER number
;Forms:
;	USER <unum>	Select specified user number;<unum> is in DEC
;
USER:	
	CALL	USRNUM		;EXTRACT USER NUMBER FROM COMMAND LINE
	LD	E,A		;PLACE USER NUMBER IN E
	CALL	SETUSR		;SET SPECIFIED USER
RSTJMP:	
	JP	RCPRNL		;RESTART CPR
;
;Section 5H
;Command: DFU
;Function:  Set the Default User Number for the command/file scanner
;	     (MEMLOAD)
;Forms:
;	DFU <unum>	Select Default User Number;<unum> is in DEC
;
	IF	Z_DFU
DFU:	
	CALL	USRNUM		;GET USER NUMBER
	LD	(DFUSR),A	;PUT IT AWAY
	JR	RSTJMP		;RESTART CPR (NO DEFAULT LOGIN)
	ENDIF
;
;Section 5I
;Command: JUMP
;Function:  To Call the program (subroutine) at the specified address
;	     without loading from disk
;Forms:
;	JUMP <adr>		Call at <adr>;<adr> is in HEX
;
	IF	NOT RAS		; NOT FOR REMOTE-ACCESS SYSTEM
	IF	Z_JUMP
;
JUMP:	
	CALL	HEXNUM		; GET LOAD ADDRESS IN HL
	JR	CALLPROG	; PERFORM CALL
;
	ENDIF			; Z_JUMP
	ENDIF			; RAS

;
;Section 5J
;Command: GO
;Function:  To Call the program in the TPA without loading
;	     loading from disk. Same as JUMP 100H, but much
;	     more convenient, especially when used with
;	     parameters for programs like STAT. Also can be
;	     allowed on remote-access systems with no problems.
;
;Form:
;	GO <parameters like for COMMAND>
;
	IF	NOT RAS		;ONLY IF RAS
	IF	Z_GO
;
GO:	LD	HL,TPA		;Always to TPA
	JR	CALLPROG	;Perform call
;
	ENDIF
	ENDIF			;END OF GO FOR RAS
;
;Section 5K
;Command: COM file processing
;Function:  To load the specified COM file from disk and execute it
;Forms:
;	<command>
;
COM:	
	LD	A,(FCBFN)	;ANY COMMAND?
	CP	' '		;' ' MEANS COMMAND WAS 'D:' TO SWITCH
	JR      NZ,COM1		;NOT <SP>, SO MUST BE TRANSIENT OR ERROR
	LD	A,(TEMPDR)	;LOOK FOR DRIVE SPEC
	OR	A		;IF ZERO, JUST BLANK
	JP	Z,RCPRNL
	DEC	A		;ADJUST FOR LOG IN
	LD	(TDRIVE),A	;SET DEFAULT DRIVE
	CALL	SETU0D		;SET DRIVE WITH USER 0
	CALL	LOGIN		;LOG IN DRIVE
	JP	RCPRNL		;RESTART CPR
COM1:	
	LD	A,(FCBFT)	;FILE TYPE MUST BE BLANK
	CP	' '
	JP	NZ,ERROR
	LD	HL,COMMSG	;PLACE DEFAULT FILE TYPE (COM) INTO FCB
	LD	DE,FCBFT	;COPY INTO FILE TYPE
	LD	BC,3		;3 BYTES
	LDIR	
	LD	HL,TPA		;SET EXECUTION/LOAD ADDRESS
	PUSH	HL		;SAVE FOR EXECUTION
	CALL	MEMLOAD		;LOAD MEMORY WITH FILE SPECIFIED IN CMD LINE
	POP	HL		;GET EXECUTION ADDRESS
	RET	NZ		;RETURN (ABORT) IF LOAD ERROR
;
; CALLPROG IS THE ENTRY POINT FOR THE EXECUTION OF THE LOADED
;   PROGRAM;ON ENTRY TO THIS ROUTINE, HL MUST CONTAIN THE EXECUTION
;   ADDRESS OF THE PROGRAM (SUBROUTINE) TO EXECUTE
;
CALLPROG:	
	LD	(EXECADR),HL	;PERFORM IN-LINE CODE MODIFICATION
	CALL	DLOGIN		;LOG IN DEFAULT DRIVE
	CALL	SCANER		;SEARCH COMMAND LINE FOR NEXT TOKEN
	LD	HL,TEMPDR	;SAVE PTR TO DRIVE SPEC
	PUSH	HL
	LD	A,(HL)		;SET DRIVE SPEC
	LD	(FCBDN),A
	LD	HL,FCBDN+10H	;PT TO 2ND FILE NAME
	CALL	SCANX		;SCAN FOR IT AND LOAD IT INTO FCBDN+16
	POP	HL		;SET UP DRIVE SPECS
	LD	A,(HL)
	LD	(FCBDM),A
	XOR	A
	LD	(FCBCR),A
	LD	DE,TFCB		;COPY TO DEFAULT FCB
	LD	HL,FCBDN	;FROM FCBDN
	LD	BC,33		;SET UP DEFAULT FCB
	LDIR	
	LD	HL,CIBUFF
COM4:	
	LD	A,(HL)		;SKIP TO END OF 2ND FILE NAME
	OR	A		;END OF LINE?
	JR      Z,COM5
	CP	' '		;END OF TOKEN?
	JR      Z,COM5
	INC	HL
	JR	COM4
;
; LOAD COMMAND LINE INTO TBUFF
;
COM5:	
	LD	B,0		;SET CHAR COUNT
	LD	DE,TBUFF+1	;PT TO CHAR POS
COM6:	
	LD	A,(HL)		;COPY COMMAND LINE TO TBUFF
	LD	(DE),A
	OR	A		;DONE IF ZERO
	JR      Z,COM7
	INC	B		;INCR CHAR COUNT
	INC	HL		;PT TO NEXT
	INC	DE
	JR	COM6
;
; RUN LOADED TRANSIENT PROGRAM
;
COM7:	
	LD	A,B		;SAVE CHAR COUNT
	LD	(TBUFF),A
	CALL	CRLF		;NEW LINE
	CALL	DEFDMA		;SET DMA TO 0080
	CALL	SETUD		;SET USER/DISK
;
; EXECUTION (CALL) OF PROGRAM (SUBROUTINE) OCCURS HERE
;
EXECADR:	EQU	$+1	;CHANGE ADDRESS FOR IN-LINE CODE MODIFICATION
	CALL	TPA		;CALL TRANSIENT
	CALL	DEFDMA		;SET DMA TO 0080, IN CASE
	;PROG CHANGED IT ON US
	CALL	SETU0D		;SET USER 0/DISK
	CALL	LOGIN		;LOGIN DISK
	JP	RESTRT		;RESTART CPR
;
; TRANSIENT LOAD ERROR
;
COM8:	
	POP	HL		;CLEAR RETURN ADDRESS
	CALL	RESETUSR	;RESET CURRENT USER NUMBER
	;  RESET MUST BE DONE BEFORE LOGIN
ERRLOG:	
	CALL	DLOGIN		;LOG IN DEFAULT DISK
ERRJMP:	
	JP	ERROR
;
;Section 5L
;Command: GET
;Function:  To load the specified file from disk to the specified address
;Forms:
;	GET <adr> <ufn>	Load the specified file at the specified page;
;			<adr> is in HEX
;
	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
	IF	Z_GET
;
GET:	
	CALL	HEXNUM		;GET LOAD ADDRESS IN HL
	PUSH	HL		;SAVE ADDRESS
	CALL	SCANER		;GET FILE NAME
	POP	HL		;RESTORE ADDRESS
	JR      NZ,ERRJMP		;MUST BE UNAMBIGUOUS
;
; FALL THRU TO MEMLOAD
;
	ENDIF
	ENDIF			;RAS
;
; LOAD MEMORY WITH THE FILE WHOSE NAME IS SPECIFIED IN THE COMMAND LINE
;   ON INPUT, HL CONTAINS STARTING ADDRESS TO LOAD
;
MEMLOAD:	
	CALL	MLOAD		;USER MEMORY LOAD SUBROUTINE
	PUSH	AF		;SAVE RETURN STATUS
	CALL	RESETUSR	;RESET USER NUMBER
	POP	AF		;GET RETURN STATUS
	RET	
;
;  MEMORY LOAD SUBROUTINE
;	EXIT POINTS ARE A SIMPLE RETURN WITH THE ZERO FLAG SET IF NO ERROR,
; A SIMPLE RETURN WITH THE ZERO FLAG RESET (NZ) IF MEMORY FULL, OR A JMP TO
; COM8 IF COM FILE NOT FOUND
;
MLOAD:	
	LD	(LOADADR),HL	;SET LOAD ADDRESS
	CALL	GETUSR		;GET CURRENT USER NUMBER
	LD	(TMPUSR),A	;SAVE IT FOR LATER
	LD	(TSELUSR),A	;TEMP USER TO SELECT
;
;   MLA is a reentry point for a non-standard CP/M Modification
; This is the return point for when the .COM (or GET) file is not found the
; first time, Drive A: is selected for a second attempt
;
MLA:	
	CALL	SLOGIN		;LOG IN SPECIFIED DRIVE IF ANY
	CALL	OPENF		;OPEN COMMAND.COM FILE
	JR      NZ,MLA1		;FILE FOUND - LOAD IT
;
; ERROR ROUTINE TO SELECT USER 0 IF ALL ELSE FAILS
;
DFUSR:	EQU	$+1		;MARK IN-THE-CODE VARIABLE
	LD	A,DEFUSR	;GET DEFAULT USER
TSELUSR:	EQU	$+1	;MARK IN-THE-CODE VARIABLE
	CP	DEFUSR		;SAME?
	JR      Z,MLA0		;JUMP IF
	LD	(TSELUSR),A	;ELSE PUT DOWN NEW ONE
	LD	E,A
	CALL	SETUSR		;GO SET NEW USER NUMBER
	JR	MLA		;AND TRY AGAIN
;
; ERROR ROUTINE TO SELECT DRIVE A: IF DEFAULT WAS ORIGINALLY SELECTED
;
MLA0:	
	LD	HL,TEMPDR	;GET DRIVE FROM CURRENT COMMAND
	XOR	A		;A=0
	OR	(HL)
	JP	NZ,COM8		;ERROR IF ALREADY DISK A:
	LD	(HL),1		;SELECT DRIVE A:
	JR	MLA
;
; FILE FOUND -- PROCEED WITH LOAD
;
EHI     EQU     HIGH ENTRY - 1
MLA1:	
LOADADR:	EQU	$+1	;MEMORY LOAD ADDRESS (IN-LINE CODE MOD)
	LD	HL,TPA		;SET START ADDRESS OF MEMORY LOAD
ML2:	
	LD	A,EHI	;GET HIGH-ORDER ADR OF JUST BELOW CPR
	CP	H		;ARE WE GOING TO OVERWRITE THE CPR?
	JR      C,PRNLE		;ERROR IF SO
	PUSH	HL		;SAVE ADDRESS OF NEXT SECTOR
	EX	DE,HL		;... IN DE
	CALL	DMASET		;SET DMA ADDRESS FOR LOAD
	LD	DE,FCBDN	;READ NEXT SECTOR
	CALL	READ
	POP	HL		;GET ADDRESS OF NEXT SECTOR
	JR      NZ,ML3		;READ ERROR OR EOF?
	LD	DE,128		;MOVE 128 BYTES PER SECTOR
	ADD	HL,DE		;PT TO NEXT SECTOR IN HL
	JR	ML2
;
ML3:	
	DEC	A		;LOAD COMPLETE
	RET	Z		;OK IF ZERO, ELSE FALL THRU TO PRNLE
;
; LOAD ERROR
;
PRNLE:	
	CALL	PRINTC
	DEFB	'Ful','l'+80H
	LD	A,1		;SET NON-ZERO TO INDICATE ERROR
	OR	A		;SET FLAG
	RET	
;
