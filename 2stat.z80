;
;    STAT: Show disks status (GPLed clone of CP/M 2 STAT)
;    Copyright (C) ????  RICH ROTH
;    Copyright (C) ????  A.R.G.
;    Copyright (C) 2018  Yuri Prokushev <yuri.prokushev@gmail.com>
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program; if not, write to the Free Software
;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;
;************************************************************
;ORIGINAL BY RICH ROTH
;TERRAN SIECH ASSOCIATES
;(203) 438-3954
;5 NORTH SALEM RD.
;RIDGEFIELD
;CT.	06877
;
;NOTE: A.R.G. ADDED A COUPLE OF SUB-ROUTINES WHICH WERE
;EXTERNALS RESOLVED BY RICH'S LOADER.
;
;REMEMBER GOOD BITS BY ROTH.
;
;************************************************************
;
;	EXTENDED STATUS PROGRAM WITH DIRECTORY
;
; LINK:  XSTAT /I  SYSLIB(BINDB,BINH2)
;
; SCHEME: 1) EXPAND ALLOCATION VECTOR TO 1 BYTE PER BIT, IN 'ALCBF'
; EACH REPRESENTING A 1K CLUSTER OF 8 CONTINGIOUS SECTORS. 
; EACH WITH MSB SET INDICATES AN ALLOCATED, BUT UNCLAIMED
; SECTOR. 
; FOR EACH DIRECTORY ENTRY DO
;     FOR EACH CLUSTER DO
;	IF THAT CLUSTER IS ALLOCATED & FREE (=80H)
;		THEN CLAIM BY FILLING IN DIRECTORY ENTRY NUMBER ;
;
;	ELSE	IF CLUSTER ISN'T ALLOCATED (=0)
;		THEN ERROR('NOT ALLOCATED')
;
;	ELSE	IF CLUSTER IS CLAIMED(=1..64)
;		THEN ERROR('LINKED CLUSTER')
;
; ON ERRORS: USE 'PRTFIL' TO CONVERT FILE NUMBER(1..64)
;	TO NAME FROM DIRECTORY BUFFER
;
;
;NO EXTERNALS ALLOWED - A.R.G.
;	EXT	BINDB,BINH2	; DECIMAL, HEX PRINT
;
	.z80
	cseg
;
CPM3	EQU	0		; CP/M 3 check
CPNET	EQU	0		; CP/NET check
Z80	EQU	0		; Z80 check
;
	INCLUDE	ZINCHEAD.INC
;
        EXT     BDOS            ; SYSLIB
;
FCBRC:	EQU	15		; FCB RECORD COUNT
CR:	EQU	13
LF:	EQU	10
DLR:	EQU	'$'

MAIN:	LD	HL,0
	ADD	HL,SP
	LD	(SAVSP),HL
;
	LD	SP,STACK
;
	LD	C,27
	CALL	BDOS		; GET DISK ALLOCATION VECTOR
	LD	HL,ALCBF
	LD	E,32
;
ALP1:	LD	D,8
	LD	A,(BC)
;
ALP2:	PUSH	AF		; DECOODE EACH BIT
	AND	80H
	LD	(HL),A
	INC	HL
	POP	AF
	RLCA	
	DEC	D
	JP	NZ,ALP2
;
	INC	BC
	DEC	E
	JP	NZ,ALP1
;
;	COUNT SPACE LEFT
; SKIP 1ST 2 CLUSTERS (THEY ARE THE DIRECTORY PROPER)
;
	LD	HL,ALCBF+2
	LD	BC,240
ALP3:	LD	A,(HL)
	OR	A
	JP	NZ,ALP4
	INC	B
ALP4:	INC	HL
	DEC	C
	JP	NZ,ALP3
	LD	C,B
	LD	B,0
	LD	HL,SPCNT
	CALL	BINDB
	LD	DE,SPCNT
	CALL	PRTLIN
;
;
;	READ IN THE DIRECTORY
;
	LD	DE,DIRBF
	PUSH	DE
	LD	C,26
	CALL	BDOS		; SET DMA FOR DIR
	LD	DE,QUEFIL
	LD	C,17
	CALL	BDOS		; FIRST FILE
	CP	255
	JP	Z,FDNE		; NO FILES
;
RDDIR:	LD	DE,QUEFIL
	LD	C,18
	CALL	BDOS		; NEXT FILE
	CP	255
	JP	Z,RDDNE
	AND	3
	CP	3		; FILE # MOD 3 =3
	JP	NZ,RDDIR
	POP	DE		; THEN INRECMENT DIR BUFF
	LD	HL,80H
	ADD	HL,DE
	EX	DE,HL
	PUSH	DE
	LD	C,26
	CALL	BDOS		; NEXT DIR BLOCK
	JP	RDDIR
;
FDNE:	LD	DE,NOFIL
	LD	C,9
	CALL	BDOS
GRTN:	LD	HL,(SAVSP)
	LD	SP,HL
	RET	
;
NOFIL:	DEFB	' NO FILES ON DISK',CR,LF,DLR
;
;
RDDNE:	POP	DE
;
;	LOG AND REPORT ON EACH FILE
;
	LD	HL,DIRBF
	XOR	A
	LD	(FILCNT),A
	LD	(FDCNT),A
;
NXFIL:	LD	(CRDIR),HL	;  NEXT FILE  , SAVE CURR. DIR ENTRY
	LD	A,(FDCNT)
	INC	A
	LD	(FDCNT),A
	LD	A,(HL)
	CP	0E5H	
	JP	Z,NXBK2	; DONE
	LD	A,(FILCNT)
	INC	A
	LD	(FILCNT),A
	LD	A,(HL)
;
	LD	DE,FCBRC
	ADD	HL,DE
	LD	A,(HL)		; CLUS. CNT:=INT((RECORD-1)/8)+1
	OR	A
	JP	NZ,NXBK1	; CHECK FOR NULL FILES
	DEC	HL
	DEC	HL
	DEC	HL
	LD	A,(HL)
	OR	A		; IF FIRST EXTENT
	JP	NZ,NXB1A	; THEN PRINT 'NULL FILE'
	LD	A,(FDCNT)
	CALL	PRTFIL
	LD	DE,NULFIL
	CALL	PRTLIN
NXB1A:	JP	NXBK2
NXBK1:	DEC	A
	AND	0F8H
	RRCA	
	RRCA	
	RRCA	
	INC	A
	LD	C,A
;
NXBLK:	INC	HL		; NEXT CLUSTER IN FILE
	PUSH	HL
	LD	E,(HL)
	LD	B,E
	LD	D,0
	LD	HL,ALCBF
	ADD	HL,DE		; CHECK ALLOCATION
	LD	A,(HL)
	PUSH	HL
;
	OR	A
	JP	NZ,NXBKA
	LD	DE,NOTALC
	CALL	PRTBLK
	JP	NXBKB
;
NXBKA:	AND	7FH
	JP	Z,NXBKC
	LD	DE,BLKLNK	; LINKED CLUSTER
	CALL	PRTBLK
	POP	HL
	LD	A,(HL)
	PUSH	HL
	CALL	PRTFIL		; ORIG FILE
;
NXBKB:	LD	A,(FDCNT)
	CALL	PRTFIL
	CALL	NEWLIN
;
NXBKC:	
	LD	A,(FDCNT)
	POP	HL
	LD	(HL),A		; ASSIGN CLUSTER TO FILE
;
	POP	HL
	DEC	C
	JP	NZ,NXBLK
;			NEXT FILE
NXBK2:	LD	HL,(CRDIR)
	LD	DE,32
	ADD	HL,DE
	LD	A,(FDCNT)
	CP	64
	JP	M,NXFIL
;
	LD	A,(FILCNT)
	LD	C,A
	LD	B,0
	LD	HL,FILECNT
	CALL	BINDB
	LD	DE,FILECNT
	CALL	PRTLIN
	JP	GRTN
;
PRTBLK:	PUSH	AF
	PUSH	BC
	PUSH	DE
	EX	DE,HL
	LD	A,B
	CALL	BINH2
	POP	DE
	LD	C,9
	CALL	BDOS
	POP	BC
	POP	AF
	RET	
;
;	A=DIR ENTRY OF FILE (TO GET NAME)
PRTFIL:	PUSH	BC		; PRINT FILE NAME
	PUSH	DE
	PUSH	AF
	DEC	A
	LD	L,A
	LD	H,0
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	LD	DE,DIRBF
	ADD	HL,DE
	INC	HL
	LD	C,11
PRTF1:	PUSH	HL
	PUSH	BC
	LD	E,(HL)
	LD	C,2
	CALL	BDOS
	POP	BC
	POP	HL
	INC	HL
	DEC	C
	JP	NZ,PRTF1
	LD	DE,SPCS
	LD	C,9
	CALL	BDOS		; SKIP SOME SPACES
	POP	AF
	POP	DE
	POP	BC
	RET	
;
NEWLIN:	
	LD	DE,CRLF
PRTLIN:	PUSH	BC
	LD	C,9
	CALL	BDOS
	POP	BC
	RET	
;
;
;
SPCNT:	DEFB	'   K  BYTES LEFT',CR,LF,CR,LF,DLR
NOTALC:	DEFB	'00H   NOT ALLOCATED ',DLR
BLKLNK:	DEFB	'00H   LINKED CLUSTER  ',DLR
SPCS:	DEFB	'     ',DLR
NULFIL:	DEFB	'   NULL FILE',CR,LF,DLR
FILECNT:	DEFB	'      DIRECTORY ENTRIES '
CRLF:	DEFB	CR,LF,DLR
CRDIR:	DEFS	2
FDCNT:	DEFB	0
FILCNT:	DEFB	0
QUEFIL:	DEFB	'?????????????'
SAVSP:	DEFS	2
;
;
;       RAM	
;
ALCBF:	DEFS	256		; CLUSTER ALLOCATION VECTOR
DIRBF:	DEFS	2048		; DIRECTORY SPACE 64 RECORDS OF 32 BYTES EA.
;
	DEFS	256
STACK:	EQU	$

;
;************************************************************
;FOLLOWING ARE AMATEUR SUBROUTINES TO
;PERFORM THE MISSING FUNCTIONS. N.B. ORIGINAL
;AUTHOR HAS NO RESPONIBILITY FOR THESE
;
;************************************************************
;LOOKS LIKE NEED A BINARY TO DECIMAL ROUTINE
;TO PUT ASCII DECIMALS INTO M[HL], +1, AND +2
;FROM THE VALUE PASSED IN C
;
BINDB:	LD	A,C		;PASSED IN C
	LD	(HL),30H	;FIX HUNDREDS TO ZERO
	JP	H2
;
H1:	INC	(HL)		;ADD 1 TO HUNDREDS
H2:	SUB	A,100
	JP	NC,H1		;NO UNDERFLOW
	ADD	A,100		;IF UNDERFLOW ADD LAST BACK
	INC	HL		;GO TO TENS
	LD	(HL),30H	;SET TO ZERO
	JP	T2
;
T1:	INC	(HL)
T2:	SUB	A,10
	JP	NC,T1
	ADD	A,10
	INC	HL		;GO TO UNITS
	LD	(HL),30H
	JP	U2
;
U1:	INC	(HL)
U2:	SUB	A,1
	JP	NC,U1
	ADD	A,1
	RET	
;
;************************************************************
;LOOKS LIKE WE NEED A BINARY TO HEX ROUTINE TO
;PUT HEX CHARACTERS INTO M[HL] AND +1 EQUIVALENT
;TO VALUE PASSED IN A
;
;
BINH2:	PUSH	AF		;SAVE BYTE
	RRCA	
	RRCA	
	RRCA	
	RRCA			;GET MOST SIGNIFICANT NIBBLE
	AND	0FH
	CALL	PUTHEX
;
	INC	HL
	POP	AF
	AND	0FH
	CALL	PUTHEX
	RET	
;
PUTHEX:	ADD	A,30H		;0-9
	CP	3AH
	JP	C,PUT2
	ADD	A,7		;A-F
PUT2:	LD	(HL),A
	RET	
;

	END
