;
;    STAT: SUBMIT packet command execution (GPLed clone of CP/M 2 SUBMIT)
;    Copyright (C) 1981  Ron Fowler
;    Copyright (C) 1981  George Gary
;    Copyright (C) 2018  Yuri Prokushev <yuri.prokushev@gmail.com>
;
;    This program is free software; you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation; either version 2 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program; if not, write to the Free Software
;    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;
;
;
;************************************************
;*		EXTENDED SUBMIT FOR		*
;*		     CP/M AND MP/M              *
;************************************************
;
; REVISED 12/22/81 :added code to so supersub would work under mp/m
;                   and cp/m. George Gary
;
; REVISED 09/13/81 (RGF): added control character translation
;			  fixed bug in line number reporting
;
;	VERSION 1.1		 by Ron Fowler
;	2/18/81 (first written)     WESTLAND, MICH.
;
;
; This program is intended as a replacement for the
; SUBMIT program provided with CP/M.  It provides sev-
; eral new facilities:
;	1) Nestable SUBMIT runs
;	2) Interactive entry of SUBMIT job (no need
;	   to use an editor for simple SUBMIT runs)
;	3) Command line entry of small SUBMIT jobs
;	4) Ability to enter blank lines in an edited
;	   SUBMIT file
;	5) User customization of number of parameters
;	   and drive to send $$$.SUB to
;
; For full details along with examples, see the ac-
; companying documentation file.
;			--Ron Fowler
;
	.z80
	cseg
;
CPM3	EQU	0		; CP/M 3 check
CPNET	EQU	0		; CP/NET check
Z80	EQU	0		; Z80 check
;
	INCLUDE	ZINCHEAD.INC
;
        EXT     BDOS            ; SYSLIB
;
; DEFINE BOOLEANS
;
FALSE:	EQU	0
TRUE:	EQU	NOT FALSE
;
;************************************************************
;
;		--  User customizable options --
;
NPAR:	EQU	10		;NUMBER OF ALLOWABLE PARAMETERS
SUBDRV:	EQU	1		;MAKE 0 FOR DFLT, 1,2,3,ETC FOR A,B,C
QUIET:	EQU	FALSE		;SET TO TRUE TO ELIMATE SIGN-ON MSG
CPBASE:	EQU	0		;SET TO 4200H FOR HEATH CP/M
;
;
;
;************************************************************
;
; CP/M DEFINITIONS
;
FPCHAR:	EQU	2		;PRINT CHAR FUNCTION
PRINTF:	EQU	9		;PRINT STRING FUNCTION
RDBUF:	EQU	10		;READ CONSOLE BUFFER
OPENF:	EQU	15		;OPEN FILE FUNCTION
CLOSEF:	EQU	16		;CLOSE FILE FUNCTION
DELETF:	EQU	19		;DELETE FILE FUNCTION
READF:	EQU	20		;READ RECORD FUNCTION
WRITEF:	EQU	21		;WRITE RECORD FUNCTION
MAKEF:	EQU	22		;MAKE (CREATE) FILE FUNCTION
;
FCB:	EQU	5CH		;DEFAULT FILE CONTROL BLOCK
FCBRC:	EQU	15		;FCB OFFSET TO RECORD COUNT
FCBNR:	EQU	32		;FCB OFFSET TO NEXT RECORD
FN:	EQU	1		;FCB OFFSET TO FILE NAME
FT:	EQU	9		;FCB OFFSET TO FILE TYPE
TBUF:	EQU	CPBASE+80H	;DEFAULT BUFFER
;
PUTCNT:	EQU	TBUF		;COUNTER FOR OUTPUT CHARS
;
; DEFINE SOME TEXT CHARACTERS
;
CR:	EQU	13		;CARRIAGE RETURN
LF:	EQU	10		;LINE FEED
TAB:	EQU	9
;
; START OF PROGRAM CODE
;
;
;	GET THE BALL ROLLING
;
MAIN:	LD	HL,0		;SAVE STACK IN CASE
	ADD	HL,SP		;  ONLY HELP REQUESTED
	LD	(SPSAVE),HL	;(NOT OTHERWISE USED)
	LD	SP,STACK
	CALL	START
;
; SIGN ON MESSAGE
;
	IF	NOT QUIET
	DEFB	'SuperSUB V1.1'
	ENDIF	
;
	DEFB	CR,LF,'$'	;NEWLINE EVEN IF QUIET
;
START:	
	POP	DE		;RETRIEVE STRING POINTER
	LD	C,PRINTF
	LD	A,(FCB+1)	;ANYTHING ON CMD LINE?
	CP	' '
	JP	Z,HELP		;NO, GO PRINT HELP
	CALL	BDOS		;PRINT THE SIGN-ON
	CALL	INITVAR		;INITIALIZE THE VARIABLE AREA
	CALL	GETPAR		;GET COMMAND LINE PARAMETERS
	CALL	SETUP		;SET UP READ OF SUBMIT FILE
	CALL	RDFILE		;READ THE SUBMIT FILE
	CALL	WRSET		;SET UP WRITE OF "$$$.SUB"
	CALL	WRSUB		;WRITE "$$$.SUB"
	JP	CPBASE		;GO START THE SUBMIT
;
;
; SETUP SETS UP THE FILE CONTROL BLOCK
; FOR READING IN THE .SUB TEXT FILE
;
SETUP:	LD	HL,FCB+FT	;LOOK AT FIRST CHAR OF
	LD	A,(HL)		;   FILE TYPE.	IF IT IS
	CP	' '		;   BLANK, THEN GO MOVE
	JP	Z,PUTSUB	;   "SUB" INTO FT FIELD
	LD	DE,SUBTYP	;IT'S NOT BLANK SO MAKE
	LD	B,3		;   SURE IT'S ALREADY
	CALL	COMPAR		;   "SUB"
	JP	NZ,NOTFND	;IF NOT, IT'S AN ERROR
	RET	
;
; MOVE "SUB" INTO THE FILE TYPE
;
PUTSUB:	EX	DE,HL		;BY CONVENTION, MOVE FROM
	LD	HL,SUBTYP	; @HL TO @DE
	LD	B,3
	CALL	MOVE
	RET	
;
; MOVE # BYTES IN B REGISTER FROM @HL TO @DE
;
MOVE:	LD	A,(HL)		;PICK UP
	LD	(DE),A		;PUT DOWN
	INC	HL		;I'M SURE
	INC	DE		; YOU'VE SEEN THIS
	DEC	B		; BEFORE...
	JP	NZ,MOVE		;100 TIMES AT LEAST
	RET			;I KNOW I HAVE!
;
; GETPAR MOVES THE SUBSTITUTION PARAMETERS SPECIFIED
; IN THE COMMAND LINE INTO MEMORY, AND STORES THEIR
; ADDRESSES IN THE PARAMETER TABLE.  THIS ALLOWS
; SUBSTITUTION OF $1, $2, ETC., IN THE SUBMIT COMMANDS
; WITH THEIR ACTUAL VALUES SPECIFED IN THE COMMAND
; LINE.
;
GETPAR:	LD	HL,TBUF+1	;WHERE WE FIND THE COMMAND TAIL
	CALL	SCANTO		;SKIP SUBMIT FILE NAME
	LD	(OPTION),A	;FIRST CHAR OF CMD LINE IS OPTION
	RET	C		;LINE ENDED?
	CP	'/'		;NO, CHECK OPTION
	JP	NZ,GLP0		;NOT KEYBOARD INP, READ FILE
	INC	HL		;POINT PAST '/'
SLSCAN:	LD	(CLPTR),HL	;SAVE CMD LINE PTR
	LD	A,(HL)		;KBD IS SOURCE, GET EOL FLAG
	LD	(CLFLAG),A	;SAVE AS EOL FLAG
	CP	' '		;ALLOW SPACES AFTER '/'
	RET	NZ		;GOT NON-BLANK, DONE
	INC	HL		;ELSE CONTINUE SCAN
	JP	SLSCAN
GLP0:	LD	A,(HL)		;INPUT IS FROM A .SUB FILE..THIS
	INC	HL		;  CODE SKIPS OVER THE NAME OF
	OR	A		;  THE SUB FILE TO GET TO THE
	RET	Z		;  COMMAND LINE PARAMETERS
	CP	' '
	JP	Z,GLP
	CP	TAB
	JP	NZ,GLP0
GLP:	CALL	SCANTO		;PASS UP THE BLANKS
	RET	C		;CY RETURNED IF END OF CMD LINE
	CALL	PUTPAR		;NOW PUT THE PARAMETER INTO MEM
	RET	C		;CY RETURNED IF END OF CMD LINE
	JP	GLP		;GET THEM ALL
;
; SCANTO SCANS PAST BLANKS TO THE FIRST NON-BLANK. IF
; END OF COMMAND LINE FOUND, RETURNS CARRY SET.
;
SCANTO:	LD	A,(HL)
	INC	HL
	OR	A		;SET FLAGS ON ZERO
	SCF			;IN CASE ZERO FOUND (END OF CMD LIN)
	RET	Z
	CP	' '
	JP	Z,SCANTO	;SCAN PAST BLANKS
	CP	TAB		;DO TABS TOO, JUST FOR
	JP	Z,SCANTO	;  GOOD MEASURE
	DEC	HL		;FOUND CHAR, POINT BACK TO IT
	OR	A		;INSURE CARRY CLEAR
	RET	
;
; PUTPAR PUTS THE PARAMETER POINTED TO BY HL INTO
; MEMORY POINTED TO BY "TXTPTR".  ALSO STORES THE
; ADDRESS OF THE PARAMETER INTO THE PARAMETER TABLE
; FOR EASY ACCESS LATER, WHEN WE WRITE $$$.SUB
;
PUTPAR:	PUSH	HL		;SAVE POINTER TO PARM
	LD	HL,(TXTPTR)	;NEXT FREE MEMORY
	EX	DE,HL		;  INTO DE
	LD	HL,(TBLPTR)	;NEXT FREE AREA OF TABLE
	LD	A,(HL)		;NON-ZERO IN TABLE
	OR	A		; INDICATES TABLE
	JP	NZ,PAROVF	; TABLE OVERFLOW (TOO MANY PARMS)
	LD	(HL),E		;STORE THE PARM ADRS
	INC	HL
	LD	(HL),D
	INC	HL
	LD	(TBLPTR),HL	;SAVE TABLE PNTR FOR NEXT TIME
	POP	HL		;GET BACK PARM POINTER
	PUSH	DE		;SAVE FREE MEM POINTER BECAUSE
	;  WE WILL HAVE TO HAVE IT BACK
	;  LATER TO STORE THE LENGTH
	INC	DE		;POINT PAST LENGTH STORAGE
	LD	B,0		;INITIALIZE LENGTH OF PARM
PPLP:	LD	A,(HL)		;GET NEXT BYTE OF PARM
	INC	HL
	OR	A		;TEST FOR END OF CMD LINE
	JP	Z,PP2		;JUMP IF END
	CP	' '		;TEST FOR END OF COMMAND
	JP	Z,PP2
	CP	TAB		;TAB ALSO ENDS COMMAND
	JP	Z,PP2
	LD	(DE),A		;PUT PARAMETER BYTE-BY-BYTE
	INC	DE		;INTO FREE MEMORY
	INC	B		;BUMP LENGTH
	JP	PPLP
PP2:	EX	DE,HL
	LD	(TXTPTR),HL	;NEW FREE MEMORY POINTER
	POP	HL		;REMEMBER OUR LENGTH POINTER?
	LD	(HL),B		;STORE THE LENGTH
	EX	DE,HL		;HAVE TO RETN HL > CMD LINE
	OR	A		;NOW RETURN END OF LINE FLAG
	SCF	
	RET	Z		;RETURN CY IF ZERO (EOL MARK)
	CCF	
	RET	
;
;	RDFILE READS THE .SUB FILE SPECIFIED
;	IN THE SUBMIT COMMAND INTO MEMORY
;
RDFILE:	LD	HL,0		;INIT LINE NUMBER
	LD	(LINNUM),HL
	LD	A,(OPTION)	;USING A FILE?
	CP	'/'		;'/' OPTION TELLS
	JP	Z,LINE		;JUMP IF NOT
	LD	DE,FCB		;WE ARE, OPEN IT
	LD	C,OPENF
	CALL	BDOS
	INC	A		;IF 0FFH RETURNED,
	JP	Z,NOTFND	;  THEN FILE NOT FOUND
LINE:	LD	HL,(LINNUM)	;BUMP LINE NUMBER
	INC	HL
	LD	(LINNUM),HL
	LD	HL,(PREV)	;GET PREV PREVIOUS LINE POINTER
	EX	DE,HL
	LD	HL,(TXTPTR)	;GET CURRENT FREE MEM POINTER
	LD	(PREV),HL	;MAKE IT THE PREV LINE (FOR NXT PASS)
	LD	(HL),E		;STORE AT BEGIN OF CURRENT LINE,
	INC	HL		;  A POINTER TO THE PREVIOUS
	LD	(HL),D
	INC	HL
	PUSH	HL		;LATER WE WILL PUT LENGTH HERE
	INC	HL		;SKIP PAST LENGTH
	LD	C,0		;INITIALIZE LENGTH TO ZERO
LLP:	CALL	GNB		;GET NEXT BYTE FROM INPUT SOURCE
	JP	C,EOFL		;CY SET IF END OF FILE FOUND
	CALL	UCASE		;CONVERT TO UPPER CASE
	CP	1AH		;SEE IF CPM END OF FILE INDICATOR
	JP	Z,EOFL
	CP	LF		;IGNORE LINEFEEDS
	JP	Z,LLP
	CP	CR		;IF IT'S A CARRIAGE RETURN,
	JP	Z,EOL		;  THEN DO END OF LINE
	LD	(HL),A		;STORE ALL OTHERS INTO MEMORY
	INC	HL
	CALL	SIZE		;MAKE SURE NO MEMORY OVERFLOW
	INC	C		;BUMP CHAR COUNT
	JP	M,LENERR	;MAX OF 128 CHARS PER LINE
	JP	LLP		;GO DO NEXT CHAR
;
;	DO END OF LINE SEQUENCE
;
EOL:	LD	(TXTPTR),HL	;SAVE FREE MEMORY POINTER
	POP	HL		;CURRENT LINE'S LENGTH POINTER
	LD	(HL),C		;STORE LENGTH AWAY
	JP	LINE		;GO DO NEXT LINE
;
;	END OF TEXT FILE
;
EOFL:	LD	(TXTPTR),HL	;SAVE FREE MEMORY POINTER
	POP	HL		;CURRENT LINE'S LENGTH POINTER
	LD	(HL),C		;STORE LENGTH AWAY
	RET			;ALL DONE READING SUB FILE
;
;	GET NEXT BYTE FROM INPUT FILE
;
GNB:	PUSH	HL		;DON'T ALTER ANYBODY
	PUSH	DE
	PUSH	BC
	LD	A,(OPTION)	;INPUT FROM .SUB FILE?
	CP	'/'		;TOLD BY ORIG CMD LINE OPTION
	JP	NZ,NSLASH	;JUMP IF WE ARE
	CALL	GNBKBD		;NO, GET A BYTE FROM KBD INPUT
	JP	GNBXIT		;THEN LEAVE
NSLASH:	LD	A,(IBP)		;GET BUFFER POINTER
	OR	A		;PAST END?
	CALL	M,FILL		;WRAPPED AROUND
	JP	NC,GNB1		;NO END OF FILE
	LD	A,1AH		;FAKE EOF
GNB1:	LD	E,A		;PUT IN DE
	LD	D,0
	INC	A		;POINT TO NEXT
	LD	(IBP),A		;PUT AWAY
	LD	HL,TBUF		;NOW OFFSET INTO BUFR
	ADD	HL,DE
	LD	A,(HL)		;GET CHAR THERE
GNBXIT:	POP	BC		;RESTORE EVERYBODY
	POP	DE
	POP	HL
	OR	A		;TURN ON CARRY
	RET	
;
;	FILL INPUT BUFFER
;
FILL:	LD	C,READF
	LD	DE,FCB
	CALL	BDOS
	OR	A		;GOT GOOD READ?
	LD	A,0		;(NEW BUF PTR)
	SCF	
	RET	NZ		;RETN CY=EOF
	CCF			;NO EOF, NO CY
	RET	
;
; COME HERE TO GET A .SUB CHARACTER WHEN
; WE'RE NOT USING A .SUB FILE ("/" OPTION)
;
GNBKBD:	LD	A,(CLFLAG)	;USE CP/M CMD LINE?
	OR	A
	JP	NZ,GNBCL	;THEN GO DO IT
	LD	A,(CLCNT)	;NOT, CHECK LOCAL
	OR	A		;  CMD LINE CHAR COUNT
	CALL	M,CLFILL	;REFILL WHEN IT WRAPS BACK
	JP	C,GKEND	;GOT CARRY (FROM CLFILL), RETURN EOF
	DEC	A		;COUNT DOWN
	LD	(CLCNT),A
	JP	P,GNBCL	;IF PLUS, BUFFER NOT EMPTY
	LD	A,CR		;OUT OF CHARS, RETURN A CR
	RET	
GKEND:	LD	A,1AH		;RETURN EOF
	RET	
;
; GET NEXT BYTE OF INPUT FROM CMD LINE @CLPTR
;
GNBCL:	LD	HL,(CLPTR)	;LOAD THE POINTER
	LD	A,(HL)		;GET THE CHAR
	INC	HL		;BUMP POINTER FOR NEXT TIME
	LD	(CLPTR),HL
	CP	';'		;LOGICAL END-OF-LINE?
	JP	NZ,NSEMI	;JUMP IF NOT
	LD	A,CR		;YES, TRANSLATE IT
	RET	
NSEMI:	OR	A		;PHYSICAL END-OF-LINE
	RET	NZ		;THIS ONLY NEEDED WHEN INPUT
	;  SOURCE IS ORIG CPM CMD LINE
	LD	A,1AH		;TRANSLATE THAT TO END OF FILE
	RET	
;
; SUBROUTINE TO RE-FILL THE LOCAL COMMAND LINE
;
CLFILL:	LD	DE,PROMPT	;PRINT A PROMPT
	LD	C,PRINTF	;USE CP/M FUNCT 9
	CALL	BDOS
	LD	DE,CLBUF	;NOW FILL THE BUFFER
	LD	C,RDBUF
	CALL	BDOS
	LD	A,(CLCNT)	;RETURN WITH COUNT IN A
	LD	HL,CLTEXT	;RESET THE CMD LINE POINTER
	LD	(CLPTR),HL
	OR	A		;SET CY ON LEN NZ
	SCF	
	RET	Z
	CCF	
	RET	
;
;	MAKE SURE NO MEMORY OVERFLOW
;
SIZE:	LD	A,(5+2)	        ;HIGHEST PAGE POINTER
	DEC	A		;MAKE IT BE UNDER BDOS
	CP	H		;CHECK IT AGAINST CURRENT PAGE
	RET	NC		;NC=ALL OKAY
	JP	MEMERR		;OTHERWISE ABORT
;
;	SET UP THE $$$.SUB FILE
;	FOR WRITING
;
WRSET:	CALL	ISMPM		;ADDED BY GAG TO CHECK FOR MP/M OPERATING SYSTEM
	LD	DE,SUBFCB
	LD	C,OPENF
	CALL	BDOS		;OPEN THE FILE
	INC	A		;CHECK CPM RETURN
	JP	Z,NONE1	;NONE EXISTS ALREADY
;
;	$$$.SUB EXISTS, SO SET
;	FCB TO APPEND TO IT
;
	LD	A,(SUBFCB+FCBRC);GET RECORD COUNT
	LD	(SUBFCB+FCBNR),A;MAKE NEXT RECORD
	RET	
;
;	COME HERE WHEN NO $$$.SUB EXISTS
;
NONE1:	LD	DE,SUBFCB
	LD	C,MAKEF
	CALL	BDOS
	INC	A
	JP	Z,NOMAKE	;0FFH=CAN'T CREATE FILE
	RET	
;
;	WRITE THE "$$$.SUB" FILE
;
WRSUB:	LD	HL,(PREV)	;THIS CODE SCANS BACKWARD
	LD	A,H		;  THRU THE FILE STORED IN
	OR	L		;  MEMORY TO THE FIRST NON-
	JP	Z,NOTEXT	;  NULL LINE.  IF NONE IS
	LD	E,(HL)		;  FOUND, ABORTS
	INC	HL
	LD	D,(HL)		;HERE, WE PICK UP PNTR TO PREV LINE
	INC	HL		;NOW WE POINT TO LENGTH
	EX	DE,HL		;WE NEED TO STORE AWAY
	LD	(PREV),HL	;  POINTER TO PREV LINE
	EX	DE,HL
	LD	A,(HL)		;NOW PICK UP THE LENGTH
	OR	A		;SET Z FLAG ON LENGTH
	JP	NZ,WRNTRY	;GOT LINE W/LENGTH: GO DO IT
	LD	HL,(LINNUM)	;NOTHING HERE, FIX LINE NUMBER
	DEC	HL		;(WORKING BACKWARD NOW)
	LD	(LINNUM),HL
	JP	WRSUB
WRLOP:	LD	HL,(PREV)	;GET PREV LINE POINTER
	LD	A,H
	OR	L		;IF THERE IS NO PREV LINE
	JP	Z,CLOSE	;  THEN WE ARE DONE
	LD	E,(HL)		;ELSE SET UP PREV FOR NEXT
	INC	HL		;  PASS THRU HERE
	LD	D,(HL)
	INC	HL
	EX	DE,HL		;NOW STORE IT AWAY
	LD	(PREV),HL
	EX	DE,HL
WRNTRY:	CALL	PUTLIN		;WRITE THE LINE TO THE FILE
	LD	HL,(LINNUM)	;BUMP THE LINE NUMBER
	DEC	HL		;DOWN (WORKING BACK NOW)
	LD	(LINNUM),HL
	JP	WRLOP
;
;	$$$.SUB IS WRITTEN, CLOSE THE FILE
;
CLOSE:	LD	DE,SUBFCB
	LD	C,CLOSEF
	JP	BDOS
;
;	THIS SUBROUTINE WRITES A LINE
;	TO THE $$$.SUB FILE BUFFER,
;	AND FLUSHES THE BUFFER AFTER
;	THE LINE IS WRITTEN.
;
PUTLIN:	LD	A,(HL)		;PICK UP LENGTH BYTE
	INC	HL		;POINT PAST IT
	LD	(GETCNT),A	;MAKE A COUNT FOR "GET"
	LD	(GETPTR),HL	;MAKE A POINTER FOR "GET"
	LD	HL,TBUF+1	;TEXT GOES AFTER LENGTH
	LD	(PUTPTR),HL	;MAKE POINTER FOR "PUT"
	XOR	A		;INITIALIZE PUT COUNT
	LD	(PUTCNT),A
	LD	B,L		;COUNT FOR CLEAR LOOP
CLR:	LD	(HL),A		;ZERO OUT BUFFER LOC
	INC	HL
	INC	B		;COUNT
	JP	NZ,CLR
;
;	THIS LOOP COLLECTS CHARACTERS
;	FROM THE LINE STORED IN MEMORY
;	AND WRITES THEM TO THE FILE.
;	IF THE "$" PARAMETER SPECIFIER
;	IS ENCOUNTERED, PARAMETER SUB-
;	STITUTION IS DONE
;
PUTLP:	CALL	GETCHR		;PICK UP A CHARACTER
	JP	C,FLUSH	;CY = NO MORE CHAR IN LINE
	CP	'^'		;CONTROL-CHAR TRANSLATE PREFIX?
	JP	NZ,NOTCX
	CALL	GETCHR		;YES, GET THE NEXT
	JP	C,CCERR	;ERROR: EARLY END OF INPUT
	SUB	A,'@'		;MAKE IT A CONTROL-CHAR
	JP	C,CCERR	;ERROR: TOO SMALL
	CP	' '
	JP	NC,CCERR	;ERROR: TOO LARGE
NOTCX:	CP	'$'		;PARAMETER SPECIFIER?
	JP	NZ,STOBYT	;IF NOT, JUST WRITE CHAR
	LD	A,(OPTION)	;CHECK OPTION: '$' DOESN'T
	CP	'/'		;  COUNT IN '/' MODE
	LD	A,'$'		;(RESTORE THE '$')
	JP	Z,STOBYT
	CALL	LKAHED		;PEEK AT NEXT CHAR
	JP	C,PARERR	;LINE ENDING MEANS PARAM ERR
	CP	'$'		;ANOTHER "$"?
	JP	NZ,SUBS		;IF NOT THEN GO DO SUBSTITUTION
	CALL	GETCHR		;GET THE 2ND "$" (WE ONLY LOOKED
	;  AHEAD BEFORE)
STOBYT:	CALL	PUTCHR		;WRITE CHAR TO FILE
	JP	PUTLP
;
;	PARAMETER SUBSTITUTION...LOOKS UP THE
;	PARAMETER # AFTER THE "$" AND PLUGS IT
;	IN IF IT EXISTS.
;
SUBS:	CALL	NUMTST		;IT BETTER BE A NUMBER
	JP	C,PARERR	;  OTHERWISE PARAM ERROR
	LD	B,0		;INITIALIZE PARM #
	JP	LPNTRY		;WE JOIN LOOP IN PROGRESS...
SUBLP:	CALL	LKAHED		;LOOK AT NEXT CHAR
	JP	C,DOSUBS	;IF LINE EMPTY, THEN PLUG IN PARM
	CALL	NUMTST		;CHECK FOR NUMERIC
	JP	C,DOSUBS	;DONE IF NOT
LPNTRY:	CALL	GETCHR		;NOW REMOVE THE CHAR FROM INPUT STREAM
	SUB	A,'0'		;REMOVE ASCII BIAS
	LD	C,A		;SAVE IT
	LD	A,B		;OUR ACCUMULATED COUNT
	ADD	A,A		;MULTIPLY  BY TEN
	ADD	A,A
	ADD	A,B
	ADD	A,A
	ADD	A,C		;THEN ADD IN NEW DIGIT
	LD	B,A		;RESTORE COUNT
	JP	SUBLP
;
;	PERFORM THE SUBSTITUTION
;
DOSUBS:	LD	A,B		;GET PARM #
	DEC	A		;MAKE ZERO RELATIVE
	JP	M,PARERR	;OOPS
	CALL	LOOKUP		;LOOK IT UP IN PARM TABLE
	JP	C,PARERR	;IT'S NOT THERE
	LD	B,A		;LENGTH IN B
SUBLP1:	INC	B		;TEST B FOR ZERO
	DEC	B
	JP	Z,PUTLP	;DONE
	LD	A,(HL)		;GET CHAR OF REAL PARAMETER
	INC	HL		;POINT PAST FOR NEXT TIME
	PUSH	HL		;SAVE REAL PARM POINTER
	CALL	PUTCHR		;PUT IT IN THE FILE
	POP	HL		;GET BACK REAL PARM POINTER
	DEC	B		;COUNTDOWN
	JP	SUBLP1
;
;	COME HERE WHEN A LINE IS FINISHED,
;	AND WE NEED TO WRITE THE BUFFER TO DISK
;
FLUSH:	LD	DE,SUBFCB
	LD	C,WRITEF
	CALL	BDOS
	OR	A
	JP	NZ,WRERR	;CPM RETURNED A WRITE ERROR
	RET	
;
;	GETCHR GETS ONE CHAR FROM
;	LINE STORED IN MEMORY
;
GETCHR:	LD	HL,GETCNT
	LD	A,(HL)		;PICK UP COUNT
	DEC	A		;REMOVE THIS CHAR
	SCF			;PRESET ERROR
	RET	M		;RETURN CY IF OUT OF CHARS
	LD	(HL),A		;UPDATE COUNT
	LD	HL,(GETPTR)	;CURRENT CHAR POINTER
	LD	A,(HL)		;PICK UP CHAR
	INC	HL		;BUMP POINTER
	LD	(GETPTR),HL	;PUT IT BACK
	CCF			;TURN CARRY OFF
	RET	
;
;	PUTCHR PUTS ONE CHAR TO
;	THE OUTPUT BUFFER
;
PUTCHR:	LD	HL,PUTCNT
	INC	(HL)		;INCREMENT COUNT
	JP	M,LENERR	;LINE WENT TO > 128 CHARS
	LD	HL,(PUTPTR)	;GET BUFFER POINTER
	LD	(HL),A		;PUT CHAR THERE
	INC	HL		;BUMP POINTER
	LD	(PUTPTR),HL	;PUT IT BACK
	RET			;ALL DONE
;
;	LOOK AHEAD ONE CHAR IN
;	THE INPUT STREAM.  SET
;	CARRY IF NONE LEFT.
;
LKAHED:	LD	A,(GETCNT)
	OR	A		;SEE IF COUNT IS DOWN TO ZERO
	SCF			;PRE SET INDICATOR
	RET	Z
	LD	A,(HL)		;PICK UP CHAR
	CCF			;TURN OFF CARRY FLAG
	RET	
;
;	LOOK UP PARAMETER WITH NUMBER IN
;	A REG. RETURN A=LENGTH OF PARM,
;	AND HL => PARAMETER
;
LOOKUP:	CP	NPAR
	JP	NC,PAROVF	;PARM # TOO HIGH
	LD	L,A
	LD	H,0		;NOW HAVE 16 BIT NUMBER
	ADD	HL,HL		;DOUBLE FOR WORD OFFSET
	LD	DE,TABLE
	ADD	HL,DE		;DO THE OFFSET
	LD	E,(HL)		;GET ADDRESS OF PARM
	INC	HL
	LD	D,(HL)
	LD	A,D		;ANYTHING THERE?
	OR	E
	JP	NZ,LKUPOK
	XOR	A		;NO, ZERO LENGTH
	RET	
LKUPOK:	EX	DE,HL		;NOW IN DE
	LD	A,(HL)		;PICK UP LENGTH
	INC	HL		;POINT PAST LENGTH
	RET	
;
;	UTILITY COMPARE SUBROUTINE
;
COMPAR:	LD	A,(DE)
	CP	(HL)
	RET	NZ
	INC	HL
	INC	DE
	DEC	B
	JP	NZ,COMPAR
	RET	
;
;	NUMERIC TEST UTILITY SUBROUTINE
;
NUMTST:	CP	'0'
	RET	C
	CP	'9'+1
	CCF	
	RET	
;
;DECIMAL OUTPUT ROUTINE
;
DECOUT:	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	BC,-10
	LD	DE,-1
;
DECOU2:	ADD	HL,BC
	INC	DE
	JP	C,DECOU2
	LD	BC,10
	ADD	HL,BC
	EX	DE,HL
	LD	A,H
	OR	L
	CALL	NZ,DECOUT
	LD	A,E
	ADD	A,'0'
	CALL	TYPE
	POP	HL
	POP	DE
	POP	BC
	RET	
;
; PRINT CR, LF ON CONSOLE
;
CRLF:	LD	A,CR
	CALL	TYPE
	LD	A,LF
;
; PRINT CHAR IN A ON CONSOLE
;
TYPE:	PUSH	HL		;SAVE REGS
	PUSH	DE
	PUSH	BC
	LD	E,A		;PUT IN E FOR CP/M
	LD	C,FPCHAR
	CALL	BDOS		;PRINT IT
	POP	BC		;RESTORE ALL
	POP	DE
	POP	HL
	RET	
;
; CONVERT CHAR IN A TO UPPER CASE
;
UCASE:	CP	'a'		;VALIDATE CASE
	RET	C
	CP	'z'+1
	RET	NC
	AND	5FH		;GOT LC, CONV TO UC
	RET	
;
;	ERROR HANDLERS
;
WRERR:	CALL	ERRXIT
	DEFB	'Disk full$'
NOMAKE:	CALL	ERRXIT
	DEFB	'Directory full$'
MEMERR:	CALL	ERRXIT
	DEFB	'Memory full$'
NOTFND:	CALL	ERRXIT
	DEFB	'Submit file not found$'
PARERR:	CALL	ERRXIT
	DEFB	'Parameter$'
PAROVF:	CALL	ERRXIT
	DEFB	'Too many parameters:$'
LENERR:	CALL	ERRXIT
	DEFB	'Line too long:$'
NOTEXT:	CALL	ERRXIT
	DEFB	'Submit file empty$'
CCERR:	CALL	ERRXIT
	DEFB	'Control character$'
ERRXIT:	POP	DE
	LD	C,PRINTF
	CALL	BDOS
	LD	DE,ERRMSG	;PRINT 2ND HALF MSG
	LD	C,PRINTF
	CALL	BDOS
	LD	HL,(LINNUM)	;TELL LINE NUMBER
	CALL	DECOUT
	CALL	CRLF
	LD	DE,SUBFCB	;DELETE THE $$$.SUB FILE
	LD	C,DELETF
	CALL	BDOS
	JP	CPBASE
;
ERRMSG:	DEFB	' error on line number: $'
;
; PROMPT FOR COMMAND LINE INPUT
;
PROMPT:	DEFB	CR,LF,'*$'
;
;	INITIALIZE ALL VARIABLES
;
INITVAR:	
	LD	HL,VAR
	LD	BC,ENDVAR-VAR
INITLP:	LD	(HL),0		;ZERO ENTIRE VAR AREA
	INC	HL
	DEC	BC
	LD	A,B
	OR	C
	JP	NZ,INITLP
	LD	HL,TABLE	;INIT PARM TABLE POINTER
	LD	(TBLPTR),HL
	LD	HL,0FFFFH	;MARK END OF TABLE
	LD	(ENDTBL),HL
	LD	HL,FREMEM	;FREE MEMORY STARTS TXT AREA
	LD	(TXTPTR),HL
	LD	A,80H		;FORCE READ
	LD	(IBP),A
	LD	(CLCNT),A	;FORCE CONSOLE READ
	RET	
;THIS ROUTINE CHECKS FOR MP/M OPERATING SYSTEM. IF IT'S CP/M THEN IT RETURNS
;IF ITS MP/M IT FINDS THE CONSOLE NO FROM THE SYSTEM AND INSERTS IT IN THE
;SECOND CHARACTER POSITION OF THE FILE TYPE IN THE FCB FOR THE SUBMIT FILE
;AND SETS A FLAG IN THE MP/M SYSTEM TO TELL IT THERE'S A SUBMIT FILE TO 
;EXECUTE WHEN THE NEXT WARM BOOT OCCURRS. GAG
ISMPM:	PUSH	AF
	PUSH	BC
	PUSH	DE
	PUSH	HL
	LD	C,0CH		;GET VERSION NUMBER IN HL
	CALL	005H
	XOR	A
	CP	H		;IS IT CP/M?
	JP	Z,RSET		;ZERO MEANS CP/M. DON'T NEED ANYTHING ELSE
MPM:	LD	C,9AH		;GET SYSTEM DATA ADDRESS IN HL
	CALL	005H
	LD	DE,80H
	ADD	HL,DE		;ADD 128 TO IT TO FIND SUBMIT FLAGS
	PUSH	HL		;SAVE POINTER TO SUBMIT FLAGS
	LD	C,99H		;GET CONSOLE NUMBER IN A
	CALL	005H
	LD	D,0
	LD	E,A		;DE = A
	ADD	A,30H		;PUT ASCII OF CONSOLE NO IN FCB
	LD	HL,CONSOL	;SECOND LETTER IN FILE TYPE IN FCB
	LD	(HL),A		;PUT ASCII OF CONSOLE NO IN FCB
	POP	HL		;RESTORE POINTER TO SUBMIT FLAGS
	ADD	HL,DE		;CONSOLE SUBMIT FLAG = PTR + CON NO.
	LD	(HL),0FFH	;SET CON SUBMIT FLAG TO TRUE
RSET:	POP	HL		;RETURN TO MAIN PROGRAM
	POP	DE
	POP	BC
	POP	AF
	RET	
;
; PRINT HELP WITH PROGRAM OPTIONS
;
HELP:	LD	DE,HLPMSG	;PRINT THE HELP STUFF
	LD	C,PRINTF
	CALL	BDOS
	LD	HL,(SPSAVE)	;THEN RETURN W/NO WARM-BOOT
	LD	SP,HL
	RET	
;
HLPMSG:	DEFB	CR,LF,'How to use SUPERSUB:',CR,LF
	DEFB	CR,LF,'SUPERSUB<CR>            :print this HELP message'
	DEFB	CR,LF,'SUPERSUB /<CR>          :go into interactive mode'
	DEFB	CR,LF,'SUPERSUB /<cmd lines>   :use SUMMARY mode'
	DEFB	CR,LF,'SUPERSUB <FILE> <PARMS> :as in standard SUBMIT.COM'
	DEFB	CR,LF
	DEFB	CR,LF,'In "/" (interactive) mode, SUPERSUB will prompt you'
	DEFB	CR,LF,'a line at a time for the SUBMIT job input...logical'
	DEFB	CR,LF,'lines may be combined on the same input line by sep-'
	DEFB	CR,LF,'erating them with semicolons.  Example:'
	DEFB	CR,LF,'  A>SUPERSUB /STAT;DIR'
	DEFB	CR,LF,'specifies two commands on the same input line.',CR,LF
	DEFB	CR,LF,'Submitted jobs may be nested...SUPERSUB does not erase'
	DEFB	CR,LF,'any existing submit job (appends to them instead).'
	DEFB	CR,LF
	DEFB	CR,LF,'To insert a control character into the output, pre-'
	DEFB	CR,LF,'fix it with a "^" (works in any mode).'
	DEFB	CR,LF,'$'
;
;	VARIABLE STORAGE
;
VAR:	EQU	$
;
TXTPTR:	DEFW	0		;FREE MEMORY POINTER
TBLPTR:	DEFW	0		;POINTER TO PARM TABLE
LINNUM:	DEFW	0		;CURRENT LINE NUMBER
PREV:	DEFW	0		;POINTER TO PREV LINE
GETCNT:	DEFB	0		;COUNTER FOR 'GET'
GETPTR:	DEFW	0		;POINTER FOR 'GET'
PUTPTR:	DEFW	0		;POINTER FOR 'PUT'
IBP:	DEFB	0		;INPUT BUFFER POINTER
CLPTR:	DEFW	0		;COMMAND LINE POINTER
CLFLAG:	DEFB	0		;USE CP/M CMD LINE FLAG
OPTION:	DEFB	0		;'/' OPTION FLAG STORE
TABLE:	DEFS	NPAR*3		;PARAMETER TABLE
ENDTBL:	DEFW	0FFFFH		;END OF PARAMETER TABLE
;
ENDVAR:	EQU	$
;
; COMMAND LINE BUFFER...NOT INITIALIZED
;
CLBUF:	DEFB	128		;BUFFER LENGTH
CLCNT:	DEFB	0		;CHARACTER COUNTER
CLTEXT:	DEFS	128		;THE BUFFER ITSELF
;
SPSAVE:	DEFW	0		;STACK POINTER SAVE
;
;
;	FCB FOR $$$.SUB
;
SUBFCB:	DEFB	SUBDRV		;DRIVE SPECIFIER
	DEFB	'$'
CONSOL:	DEFB	'$'		; IF MPM THEN PUT ASCII OF CONSOLE NO HERE.
	DEFB	'$     '
SUBTYP:	DEFB	'SUB'
	DEFW	0,0,0,0		;INITIALIZE REST OF FCB
	DEFW	0,0,0,0
	DEFW	0,0
;
;	STACK AREA
;
	DEFS	200		;WHY NOT?
STACK:	EQU	$
FREMEM:	EQU	$
;
	END
