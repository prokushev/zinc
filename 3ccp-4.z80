;
;**** Section 4 ****
; CPR UTILITIES
;
; SET USER/DISK FLAG TO CURRENT USER AND DEFAULT DISK
;
SETUD:	
	CALL	GETUSR		;GET NUMBER OF CURRENT USER
	ADD	A,A		;PLACE IT IN HIGH NYBBLE
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	HL,TDRIVE	;MASK IN DEFAULT DRIVE NUMBER (LOW NYBBLE)
	OR	(HL)		;MASK IN
	LD	(UDFLAG),A	;SET USER/DISK NUMBER
	RET	
;
; SET USER/DISK FLAG TO USER 0 AND DEFAULT DISK
;
SETU0D:	
TDRIVE:	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TDRIVE
	LD	(UDFLAG),A	;SET USER/DISK NUMBER
	RET	
;
; CONVERT CHAR IN A TO UPPER CASE
;
UCASE:	
	CP	61H		;LOWER-CASE A
	RET	C
	CP	7BH		;GREATER THAN LOWER-CASE Z?
	RET	NC
	AND	5FH		;CAPITALIZE
	RET	
;
; INPUT NEXT COMMAND TO CPR
;	This routine determines if a SUBMIT file is being processed
; and extracts the command line from it if so or from the user's console
;
REDBUF:	
	LD	A,(RNGSUB)	;SUBMIT FILE CURRENTLY IN EXECUTION?
	OR	A		;0=NO
	JR      Z,RB1		;GET LINE FROM CONSOLE IF NOT
	LD	DE,SUBFCB	;OPEN $$$.SUB
	PUSH	DE		;SAVE DE
	CALL	OPEN
	POP	DE		;RESTORE DE
	JR      Z,RB1		;ERASE $$$.SUB IF END OF FILE AND GET CMND
	LD	A,(SUBFRC)	;GET VALUE OF LAST RECORD IN FILE
	DEC	A		;PT TO NEXT TO LAST RECORD
	LD	(SUBFCR),A	;SAVE NEW VALUE OF LAST RECORD IN $$$.SUB
	CALL	READ		;DE=SUBFCB
	JR      NZ,RB1		;ABORT $$$.SUB IF ERROR IN READING LAST REC
	LD	DE,CBUFF	;COPY LAST RECORD (NEXT SUBMIT CMND) TO CBUFF
	LD	HL,TBUFF	;  FROM TBUFF
	LD	BC,BUFLEN	;NUMBER OF BYTES
	LDIR	
	LD	HL,SUBFS2	;PT TO S2 OF $$$.SUB FCB
	LD	(HL),0		;SET S2 TO ZERO
	INC	HL		;PT TO RECORD COUNT
	DEC	(HL)		;DECREMENT RECORD COUNT OF $$$.SUB
	LD	DE,SUBFCB	;CLOSE $$$.SUB
	CALL	CLOSE
	JR      Z,RB1		;ABORT $$$.SUB IF ERROR
	LD	A,SPRMPT	;PRINT SUBMIT PROMPT
	CALL	CONOUT
	LD	HL,CIBUFF	;PRINT COMMAND LINE FROM $$$.SUB
	CALL	PRIN1
	CALL	BREAK		;CHECK FOR ABORT (ANY CHAR)
;
	IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
	RET	Z		;IF <NULL> (NO ABORT), RETURN TO CALLER AND RUN
	ENDIF	
;
	IF	NOT CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
	JR      Z,CNVBUF		;IF <NULL> (NO ABORT), CAPITALIZE COMMAND
	ENDIF	
;
	CALL	SUBKIL		;KILL $$$.SUB IF ABORT
	JP	RESTRT		;RESTART CPR
;
; INPUT COMMAND LINE FROM USER CONSOLE
;
RB1:	
	CALL	SUBKIL		;ERASE $$$.SUB IF PRESENT
	CALL	SETUD		;SET USER AND DISK
	LD	A,CPRMPT	;PRINT PROMPT
	CALL	CONOUT
	LD	C,0AH		;READ COMMAND LINE FROM USER
	LD	DE,MBUFF
	CALL	BDOS
;
	IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
	JP	SETU0D		;SET CURRENT DISK NUMBER IN LOWER PARAMS
	ENDIF	
;
	IF	NOT CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
	CALL	SETU0D		;SET CURRENT DISK NUMBER IF LOWER PARAMS
	; AND FALL THRU TO CNVBUF
	ENDIF	
;
; CAPITALIZE STRING (ENDING IN 0) IN CBUFF AND SET PTR FOR PARSING
;
CNVBUF:	
	LD	HL,CBUFF	;PT TO USER'S COMMAND
	LD	B,(HL)		;CHAR COUNT IN B
	INC	B		;ADD 1 IN CASE OF ZERO
CB1:	
	INC	HL		;PT TO 1ST VALID CHAR
	LD	A,(HL)		;CAPITALIZE COMMAND CHAR
	CALL	UCASE
	LD	(HL),A
	DJNZ	CB1		;CONTINUE TO END OF COMMAND LINE
CB2:	
	LD	(HL),0		;STORE ENDING <NULL>
	LD	HL,CIBUFF	;SET COMMAND LINE PTR TO 1ST CHAR
	LD	(CIBPTR),HL
	RET	
;
; CHECK FOR ANY CHAR FROM USER CONSOLE;RET W/ZERO SET IF NONE
;
BREAK:	
	PUSH	DE		;SAVE DE
	LD	C,11		;CSTS CHECK
	CALL	BDOSB
	CALL	NZ,CONIN	;GET INPUT CHAR
BRKBK:	
	POP	DE
	RET	
;
; GET THE REQUESTED USER NUMBER FROM THE COMMAND LINE AND VALIDATE IT.
;
USRNUM:	
	CALL	NUMBER
	CP	MAXUSR+1
	RET	C
;
; INVALID COMMAND -- PRINT IT
;
ERROR:	
	CALL	CRLF		;NEW LINE
	LD	HL,(CIPTR)	;PT TO BEGINNING OF COMMAND LINE
ERR2:	
	LD	A,(HL)		;GET CHAR
	CP	' '+1		;SIMPLE '?' IF <SP> OR LESS
	JR      C,ERR1
	PUSH	HL		;SAVE PTR TO ERROR COMMAND CHAR
	CALL	CONOUT		;PRINT COMMAND CHAR
	POP	HL		;GET PTR
	INC	HL		;PT TO NEXT
	JR	ERR2		;CONTINUE
ERR1:	
	CALL	PRINT		;PRINT '?'
	DEFB	'?'+80H
	CALL	SUBKIL		;TERMINATE ACTIVE $$$.SUB IF ANY
	JP	RESTRT		;RESTART CPR
;
; CHECK TO SEE IF DE PTS TO DELIMITER; IF SO, RET W/ZERO FLAG SET
;
SDELM:	
	LD	A,(DE)
	OR	A		;0=DELIMITER
	RET	Z
	CP	' '		;ERROR IF < <SP>
	JR      C,ERROR
	RET	Z		;<SP>=DELIMITER
	CP	'='		;'='=DELIMITER
	RET	Z
	CP	5FH		;UNDERSCORE=DELIMITER
	RET	Z
	CP	'.'		;'.'=DELIMITER
	RET	Z
	CP	':'		;':'=DELIMITER
	RET	Z
	CP	';'		;';'=DELIMITER
	RET	Z
	CP	'<'		;'<'=DELIMITER
	RET	Z
	CP	'>'		;'>'=DELIMITER
	RET	
;
; ADVANCE INPUT PTR TO FIRST NON-BLANK AND FALL THROUGH TO SBLANK
;
ADVAN:	
	LD      DE,(CIBPTR)
;
; SKIP STRING PTED TO BY DE (STRING ENDS IN 0) UNTIL END OF STRING
;   OR NON-BLANK ENCOUNTERED (BEGINNING OF TOKEN)
;
SBLANK:	
	LD	A,(DE)
	OR	A
	RET	Z
	CP	' '
	RET	NZ
	INC	DE
	JR	SBLANK
;
; ADD A TO HL (HL=HL+A)
;
ADDAH:	
	ADD	A,L
	LD	L,A
	RET	NC
	INC	H
	RET	
;
; EXTRACT DECIMAL NUMBER FROM COMMAND LINE
;   RETURN WITH VALUE IN REG A;ALL REGISTERS MAY BE AFFECTED
;
NUMBER:	
	CALL	SCANER		;PARSE NUMBER AND PLACE IN FCBFN
	LD	HL,FCBFN+10	;PT TO END OF TOKEN FOR CONVERSION
	LD	B,11		;11 CHARS MAX
;
; CHECK FOR SUFFIX FOR HEXADECIMAL NUMBER
;
NUMS:	
	LD	A,(HL)		;GET CHARS FROM END, SEARCHING FOR SUFFIX
	DEC	HL		;BACK UP
	CP	' '		;SPACE?
	JR      NZ,NUMS1		;CHECK FOR SUFFIX
	DJNZ	NUMS		;COUNT DOWN
	JR	NUM0		;BY DEFAULT, PROCESS
NUMS1:	
	CP	NUMBASE		;CHECK AGAINST BASE SWITCH FLAG
	JR      Z,HNUM0
;
; PROCESS DECIMAL NUMBER
;
NUM0:	
	LD	HL,FCBFN	;PT TO BEGINNING OF TOKEN
	LD	BC,1100H	;C=ACCUMULATED VALUE, B=CHAR COUNT
	; (C=0, B=11)
NUM1:	
	LD	A,(HL)		;GET CHAR
	CP	' '		;DONE IF <SP>
	JR      Z,NUM2
	INC	HL		;PT TO NEXT CHAR
	SUB	A,'0'		;CONVERT TO BINARY (ASCII 0-9 TO BINARY)
	CP	10		;ERROR IF >= 10
	JR      NC,NUMERR
	LD	D,A		;DIGIT IN D
	LD	A,C		;NEW VALUE = OLD VALUE * 10
	RLCA	
	RLCA	
	RLCA	
	ADD	A,C		;CHECK FOR RANGE ERROR
	JR      C,NUMERR
	ADD	A,C		;CHECK FOR RANGE ERROR
	JR      C,NUMERR
	ADD	A,D		;NEW VALUE = OLD VALUE * 10 + DIGIT
	JR      C,NUMERR		;CHECK FOR RANGE ERROR
	LD	C,A		;SET NEW VALUE
	DJNZ	NUM1		;COUNT DOWN
;
; RETURN FROM NUMBER
;
NUM2:	
	LD	A,C		;GET ACCUMULATED VALUE
	RET	
;
; NUMBER ERROR ROUTINE FOR SPACE CONSERVATION
;
NUMERR:	
	JP	ERROR		;USE ERROR ROUTINE - THIS IS RELATIVE PT
;
; EXTRACT HEXADECIMAL NUMBER FROM COMMAND LINE
;   RETURN WITH VALUE IN REG A; ALL REGISTERS MAY BE AFFECTED
;
HEXNUM:	
	CALL	SCANER		;PARSE NUMBER AND PLACE IN FCBFN
HNUM0:	
	LD	HL,FCBFN	;PT TO TOKEN FOR CONVERSION
	LD	DE,0		;DE=ACCUMULATED VALUE
	LD	B,11		;B=CHAR COUNT
HNUM1:	
	LD	A,(HL)		;GET CHAR
	CP	' '		;DONE?
	JR      Z,HNUM3		;RETURN IF SO
	CP	NUMBASE		;DONE IF NUMBASE SUFFIX
	JR      Z,HNUM3
	SUB	A,'0'		;CONVERT TO BINARY
	JR      C,NUMERR		;RETURN AND DONE IF ERROR
	CP	10		;0-9?
	JR      C,HNUM2
	SUB	A,7		;A-F?
	CP	10H		;ERROR?
	JR      NC,NUMERR
HNUM2:	
	INC	HL		;PT TO NEXT CHAR
	LD	C,A		;DIGIT IN C
	LD	A,D		;GET ACCUMULATED VALUE
	RLCA			;EXCHANGE NYBBLES
	RLCA	
	RLCA	
	RLCA	
	AND	0F0H		;MASK OUT LOW NYBBLE
	LD	D,A
	LD	A,E		;SWITCH LOW-ORDER NYBBLES
	RLCA	
	RLCA	
	RLCA	
	RLCA	
	LD	E,A		;HIGH NYBBLE OF E=NEW HIGH OF E,
	;  LOW NYBBLE OF E=NEW LOW OF D
	AND	0FH		;GET NEW LOW OF D
	OR	D		;MASK IN HIGH OF D
	LD	D,A		;NEW HIGH BYTE IN D
	LD	A,E
	AND	0F0H		;MASK OUT LOW OF E
	OR	C		;MASK IN NEW LOW
	LD	E,A		;NEW LOW BYTE IN E
	DJNZ	HNUM1		;COUNT DOWN
;
; RETURN FROM HEXNUM
;
HNUM3:	
	EX	DE,HL		;RETURNED VALUE IN HL
	LD	A,L		;LOW-ORDER BYTE IN A
	RET	
;
; PT TO DIRECTORY ENTRY IN TBUFF WHOSE OFFSET IS SPECIFIED BY A AND C
;
DIRPTR:	
	LD	HL,TBUFF	;PT TO TEMP BUFFER
	ADD	A,C		;PT TO 1ST BYTE OF DIR ENTRY
	CALL	ADDAH		;PT TO DESIRED BYTE IN DIR ENTRY
	LD	A,(HL)		;GET DESIRED BYTE
	RET	
;
; CHECK FOR SPECIFIED DRIVE AND LOG IT IN IF NOT DEFAULT
;
SLOGIN:	
	XOR	A		;SET FCBDN FOR DEFAULT DRIVE
	LD	(FCBDN),A
	CALL	COMLOG		;CHECK DRIVE
	RET	Z
	JR	DLOG5		;DO LOGIN OTHERWISE
;
; CHECK FOR SPECIFIED DRIVE AND LOG IN DEFAULT DRIVE IF SPECIFIED<>DEFAULT
;
DLOGIN:	
	CALL	COMLOG		;CHECK DRIVE
	RET	Z		;ABORT IF SAME
	LD	A,(TDRIVE)	;LOG IN DEFAULT DRIVE
;
DLOG5:	JP	LOGIN
;
; ROUTINE COMMON TO BOTH LOGIN ROUTINES; ON EXIT, Z SET MEANS ABORT
;
COMLOG:	
TEMPDR:	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TEMPDR
	OR	A		;0=NO
	RET	Z
	DEC	A		;COMPARE IT AGAINST DEFAULT
	LD	HL,TDRIVE
	CP	(HL)
	RET			;ABORT IF SAME
;
; EXTRACT TOKEN FROM COMMAND LINE AND PLACE IT INTO FCBDN;
;   FORMAT FCBDN FCB IF TOKEN RESEMBLES FILE NAME AND TYPE (FILENAME.TYP);
;   ON INPUT, CIBPTR PTS TO CHAR AT WHICH TO START SCAN;
;   ON OUTPUT, CIBPTR PTS TO CHAR AT WHICH TO CONTINUE AND ZERO FLAG IS RESET
;     IF '?' IS IN TOKEN
;
; ENTRY POINTS:
;	SCANER - LOAD TOKEN INTO FIRST FCB
;	SCANX - LOAD TOKEN INTO FCB PTED TO BY HL
;
SCANER:	
	LD	HL,FCBDN	;POINT TO FCBDN
SCANX:	
	XOR	A		;SET TEMPORARY DRIVE NUMBER TO DEFAULT
	LD	(TEMPDR),A
	CALL	ADVAN		;SKIP TO NON-BLANK OR END OF LINE
	LD	(CIPTR),DE		;SET PTR TO NON-BLANK OR END OF LINE
	LD	A,(DE)		;END OF LINE?
	OR	A		;0=YES
	JR      Z,SCAN2
	SBC	A,'A'-1		;CONVERT POSSIBLE DRIVE SPEC TO NUMBER
	LD	B,A		;STORE NUMBER (A:=0, B:=1, ETC) IN B
	INC	DE		;PT TO NEXT CHAR
	LD	A,(DE)		;SEE IF IT IS A COLON (:)
	CP	':'
	JR      Z,SCAN3		;YES, WE HAVE A DRIVE SPEC
	DEC	DE		;NO, BACK UP PTR TO FIRST NON-BLANK CHAR
SCAN2:	
	LD	A,(TDRIVE)	;SET 1ST BYTE OF FCBDN AS DEFAULT DRIVE
	LD	(HL),A
	JR	SCAN4
SCAN3:	
	LD	A,B		;WE HAVE A DRIVE SPEC
	LD	(TEMPDR),A	;SET TEMPORARY DRIVE
	LD	(HL),B		;SET 1ST BYTE OF FCBDN AS SPECIFIED DRIVE
	INC	DE		;PT TO BYTE AFTER ':'
;
; EXTRACT FILENAME FROM POSSIBLE FILENAME.TYP
;
SCAN4:	
	XOR	A		;A=0
	LD	(QMCNT),A	;INIT COUNT OF NUMBER OF QUESTION MARKS IN FCB
	LD	B,8		;MAX OF 8 CHARS IN FILE NAME
	CALL	SCANF		;FILL FCB FILE NAME
;
; EXTRACT FILE TYPE FROM POSSIBLE FILENAME.TYP
;
	LD	B,3		;PREPARE TO EXTRACT TYPE
	CP	'.'		;IF (DE) DELIMITER IS A '.', WE HAVE A TYPE
	JR      NZ,SCAN15		;FILL FILE TYPE BYTES WITH <SP>
	INC	DE		;PT TO CHAR IN COMMAND LINE AFTER '.'
	CALL	SCANF		;FILL FCB FILE TYPE
	JR	SCAN16		;SKIP TO NEXT PROCESSING
SCAN15:	
	CALL	SCANF4		;SPACE FILL
;
; FILL IN EX, S1, S2, AND RC WITH ZEROES
;
SCAN16:	
	LD	B,4		;4 BYTES
SCAN17:	
	INC	HL		;PT TO NEXT BYTE IN FCBDN
	LD	(HL),0
	DJNZ	SCAN17
;
; SCAN COMPLETE -- DE PTS TO DELIMITER BYTE AFTER TOKEN
;
	LD	(CIBPTR),DE
;
; SET ZERO FLAG TO INDICATE PRESENCE OF '?' IN FILENAME.TYP
;
	LD	A,(QMCNT)	;GET NUMBER OF QUESTION MARKS
	OR	A		;SET ZERO FLAG TO INDICATE ANY '?'
	RET	
;
;  SCANF -- SCAN TOKEN PTED TO BY DE FOR A MAX OF B BYTES; PLACE IT INTO
;    FILE NAME FIELD PTED TO BY HL; EXPAND AND INTERPRET WILD CARDS OF
;    '*' AND '?'; ON EXIT, DE PTS TO TERMINATING DELIMITER
;
SCANF:	
	CALL	SDELM		;DONE IF DELIMITER ENCOUNTERED - <SP> FILL
	JR      Z,SCANF4
	INC	HL		;PT TO NEXT BYTE IN FCBDN
	CP	'*'		;IS (DE) A WILD CARD?
	JR      NZ,SCANF1		;CONTINUE IF NOT
	LD	(HL),'?'	;PLACE '?' IN FCBDN AND DON'T ADVANCE DE IF SO
	CALL	SCQ		;SCANNER COUNT QUESTION MARKS
	JR	SCANF2
SCANF1:	
	LD	(HL),A		;STORE FILENAME CHAR IN FCBDN
	INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
	CP	'?'		;CHECK FOR QUESTION MARK (WILD)
	CALL	Z,SCQ		;SCANNER COUNT QUESTION MARKS
SCANF2:	
	DJNZ	SCANF		;DECREMENT CHAR COUNT UNTIL 8 ELAPSED
SCANF3:	
	CALL	SDELM		;8 CHARS OR MORE - SKIP UNTIL DELIMITER
	RET	Z		;ZERO FLAG SET IF DELIMITER FOUND
	INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
	JR	SCANF3
;
;  FILL MEMORY POINTED TO BY HL WITH SPACES FOR B BYTES
;
SCANF4:	
	INC	HL		;PT TO NEXT BYTE IN FCBDN
	LD	(HL),' '	;FILL FILENAME PART WITH <SP>
	DJNZ	SCANF4
	RET	
;
;  INCREMENT QUESTION MARK COUNT FOR SCANNER
;    THIS ROUTINE INCREMENTS THE COUNT OF THE NUMBER OF QUESTION MARKS IN
;    THE CURRENT FCB ENTRY
;
SCQ:	
	LD	A,(QMCNT)	;GET COUNT
	INC	A		;INCREMENT
	LD	(QMCNT),A	;PUT COUNT
	RET	
;
; CMDTBL (COMMAND TABLE) SCANNER
;   ON RETURN, HL PTS TO ADDRESS OF COMMAND IF CPR-RESIDENT
;   ON RETURN, ZERO FLAG SET MEANS CPR-RESIDENT COMMAND
;
CMDSER:	
	LD	HL,CMDTBL	;PT TO COMMAND TABLE
	LD	C,NCMNDS	;SET COMMAND COUNTER
CMS1:	
	LD	DE,FCBFN	;PT TO STORED COMMAND NAME
	LD	B,NCHARS	;NUMBER OF CHARS/COMMAND (8 MAX)
CMS2:	
	LD	A,(DE)		;COMPARE AGAINST TABLE ENTRY
	CP	(HL)
	JR      NZ,CMS3		;NO MATCH
	INC	DE		;PT TO NEXT CHAR
	INC	HL
	DJNZ	CMS2		;COUNT DOWN
	LD	A,(DE)		;NEXT CHAR IN INPUT COMMAND MUST BE <SP>
	CP	' '
	JR      NZ,CMS4
	RET			;COMMAND IS CPR-RESIDENT (ZERO FLAG SET)
CMS3:	
	INC	HL		;SKIP TO NEXT COMMAND TABLE ENTRY
	DJNZ	CMS3
CMS4:	
	INC	HL		;SKIP ADDRESS
	INC	HL
	DEC	C		;DECREMENT TABLE ENTRY NUMBER
	JR      NZ,CMS1
	INC	C		;CLEAR ZERO FLAG
	RET			;COMMAND IS DISK-RESIDENT (ZERO FLAG CLEAR)
