;
; SYSLIB Module Name:  SFNAME
; Author:  Richard Conn
; SYSLIB Version Number:  3.6
; Module Version Number:  1.1

	public	fname

;
;  FNAME is a file name scanner.  Pointing to the first character
;	of a file name specification of the form 'du:filename.typ', where
;	any part of this specification is optional, this routine fills in
;	an FCB with zeros, properly initializes the FN and FT (File Name and
;	File Type) fields if 'filename.typ' or any part thereof is present,
;	and returns the value of d and u if they are specified (or FFH if they
;	are not).
;

;
;  EXTERNALS
;
	EXT	CAPS	; CAPITALIZE ROUTINE

;
;  BASIC EQUATES
;
MAXDISK	EQU	16	; MAX NUMBER OF DISKS
MAXUSER	EQU	31	; MAX USER NUMBER
CPM	EQU	0	; CP/M ENTRY
CR	EQU	0DH
LF	EQU	0AH

;
;  MAIN MODULE
;	ON ENTRY, DE PTS TO FCB TO BE FILLED AND HL PTS TO FIRST BYTE OF
;		TARGET STRING; FCB IS 36 BYTES LONG
;	ON EXIT, B=DISK NUMBER (1 FOR A, ETC) AND C=USER NUMBER
;		HL PTS TO TERMINATING CHAR
;		A=0 AND Z SET IF ERROR IN DISK OR USER NUMBERS, A=0FFH AND NZ
;			IF OK
;
FNAME:
	PUSH	DE	; SAVE DE
	LD	A,0FFH	; SET DEFAULT DISK AND USER
	LD	(DISK),A
	LD	(USER),A
	LD	B,36	; INIT FCB
	PUSH	DE	; SAVE PTR
	XOR	A	; A=0
FNINI:
	LD	(DE),A	; STORE ZERO
	INC	DE	; PT TO NEXT
	DEC	B	; COUNT DOWN
	JP	NZ,FNINI
	POP	DE	; GET PTR BACK
;
;  SCAN FOR COLON IN STRING
;
	PUSH	HL	; SAVE PTR
COLON:
	LD	A,(HL)	; SCAN FOR COLON OR SPACE
	INC	HL	; PT TO NEXT
	CP	':'	; COLON FOUND?
	JP	Z,COLON1
	CP	','	; COMMA FOUND?
	JP	Z,GETF1
	CP	' '+1	; DELIM?
	JP	C,GETF1
	JP	COLON	; CONTINUE IF NOT END OF LINE
COLON1:
	POP	HL	; CLEAR STACK
	LD	A,(HL)	; SAVE POSSIBLE DRIVE SPEC
	CALL	CAPS	; CAPITALIZE
	CP	'A'	; DIGIT IF LESS THAN 'A'
	JP	C,USERCK	; PROCESS USER NUMBER
	SUB	'A'	; CONVERT TO 0-15
	CP	MAXDISK	; WITHIN BOUNDS?
	JP	C,SVDISK
ERREXIT:
	XOR	A	; ERROR INDICATOR
	POP	DE	; RESTORE DE
	RET

;  LOG IN SPECIFIED DISK
SVDISK:
	INC	A	; ADJUST TO 1 FOR A
	LD	(DISK),A	; SAVE FLAG
	INC	HL	; PT TO NEXT CHAR

;  CHECK FOR USER
USERCK:
	LD	A,(HL)	; GET POSSIBLE USER NUMBER
	CP	':'	; NO USER NUMBER
	JP	Z,GETFILE
	CP	'?'	; ALL USER NUMBERS?
	JP	NZ,USERC1
	LD	(USER),A	; SET VALUE
	INC	HL	; PT TO AFTER
	LD	A,(HL)	; MUST BE COLON
	CP	':'
	JP	Z,GETFILE
	JP	ERREXIT	; FATAL ERROR IF NOT COLON AFTER ?
USERC1:
	XOR	A	; ZERO USER NUMBER
	LD	B,A	; B=ACCUMULATOR FOR USER NUMBER
USRLOOP:
	LD	A,(HL)	; GET DIGIT
	INC	HL	; PT TO NEXT
	CP	':'	; DONE?
	JP	Z,USRDN
	SUB	'0'	; CONVERT TO BINARY
	JP	C,ERREXIT	; USER NUMBER ERROR?
	CP	10
	JP	NC,ERREXIT
	LD	C,A	; NEXT DIGIT IN C
	LD	A,B	; OLD NUMBER IN A
	ADD	A,A	; *2
	ADD	A,A	; *4
	ADD	A,B	; *5
	ADD	A,A	; *10
	ADD	A,C	; *10+NEW DIGIT
	LD	B,A	; RESULT IN B
	JP	USRLOOP
USRDN:
	LD	A,B	; GET NEW USER NUMBER
	CP	MAXUSER+1	; WITHIN RANGE?
	JP	NC,ERREXIT
	LD	(USER),A	; SAVE IN FLAG
	JP	GETFILE

;  EXTRACT FILE NAME
GETF1:
	POP	HL	; GET PTR TO BYTE
GETFILE:
	LD	A,(HL)	; PTING TO COLON?
	CP	':'
	JP	NZ,GFILE1
	INC	HL	; SKIP OVER COLON
GFILE1:
	LD	A,(HL)	; GET NEXT CHAR
	CP	','	; DELIM?
	JP	Z,GFQUES
	CP	' '+1	; NOT A DELIMITER?
	JP	NC,GFILE2
GFQUES:
	INC	DE	; FILL WITH '?'
	LD	B,11	; 11 BYTES
	LD	A,'?'
GFFILL:
	LD	(DE),A	; PUT ?
	INC	DE	; PT TO NEXT
	DEC	B	; COUNT DOWN
	JP	NZ,GFFILL
FNDONE:
	LD	A,(DISK)	; GET DISK NUMBER
	LD	B,A	; ... IN B
	LD	A,(USER)	; GET USER NUMBER
	LD	C,A	; ... IN C
	POP	DE	; RESTORE REGS
	LD	A,0FFH	; NO ERROR
	OR	A	; SET FLAGS
	RET
;  GET FILE NAME FIELDS
GFILE2:
	LD	B,8	; AT MOST 8 BYTES FOR FN
	CALL	SCANF	; SCAN AND FILL
	LD	B,3	; AT MOST 3 BYTES FOR FT
	LD	A,(HL)	; GET DELIMITER
	CP	'.'	; FN ENDING IN '.'?
	JP	NZ,GFILE3
	INC	HL	; PT TO CHAR AFTER '.'
	CALL	SCANF	; SCAN AND FILL
	JP	FNDONE	; DONE ... RETURN ARGS
GFILE3:
	CALL	SCANF4	; FILL WITH <SP>
	JP	FNDONE
;
;  SCANNER ROUTINE
;
SCANF:
	CALL	DELCK	; CHECK FOR DELIMITER
	JP	Z,SCANF4	; <SP> FILL IF FOUND
	INC	DE	; PT TO NEXT BYTE IN FN
	CP	'*'	; ? FILL?
	JP	NZ,SCANF1
	LD	A,'?'	; PLACE '?'
	LD	(DE),A
	JP	SCANF2
SCANF1:
	LD	(DE),A	; PLACE CHAR
	INC	HL	; PT TO NEXT POSITION
SCANF2:
	DEC	B	; COUNT DOWN
	JP	NZ,SCANF	; CONTINUE LOOP
SCANF3:
	CALL	DELCK	; "B" CHARS OR MORE - SKIP TO DELIMITER
	RET	Z
	INC	HL	; PT TO NEXT
	JP	SCANF3
SCANF4:
	INC	DE	; PT TO NEXT FN OR FT
	LD	A,' '	; <SP> FILL
	LD	(DE),A
	DEC	B	; COUNT DOWN
	JP	NZ,SCANF4
	RET

;
;  BUFFERS
;
DISK:	DS	1	; DISK NUMBER
USER:	DS	1	; USER NUMBER

;
;  CHECK CHAR PTED TO BY HL FOR A DELIMITER
;    RET WITH Z FLAG SET IF DELIMITER
;
DELCK:
	LD	A,(HL)	; GET CHAR
	CALL	CAPS	; CAPITALIZE
	OR	A	; 0=DELIM
	RET	Z
	CP	' '+1	; <SP>+1
	JP	C,DELCK1	; <SP> OR LESS
	CP	'='
	RET	Z
	CP	5FH	; UNDERSCORE
	RET	Z
	CP	'.'
	RET	Z
	CP	':'
	RET	Z
	CP	';'
	RET	Z
	CP	','
	RET	Z
	CP	'<'
	RET	Z
	CP	'>'
	RET
DELCK1:
	CP	(HL)	; COMPARE WITH SELF FOR OK
	RET

	END
